<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>K-means算法及python实现</title>
    <url>/2019/07/19/k-means-ju-lei-suan-fa-yuan-li-ji-python-shi-xian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K-means(Thek-meansalgorithm)是机器学习十大经典算法之一，同时也是最为经典的无监督聚类（Unsupervised Clustering）算法。接触聚类算法，首先需要了解k-means算法的实现原理和步骤。本文将对k-means算法的基本原理和实现实例进行分析。</p>
<h1 id="一-聚类算法的简介"><a href="#一-聚类算法的简介" class="headerlink" title="一.聚类算法的简介"></a>一.聚类算法的简介</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于”<strong>监督学习</strong>“(supervised learning)，其训练样本<strong>是带有标记信息</strong>的，并且监督学习的<strong>目的是</strong>：对带有标记的数据集进行模型学习，从而便于对新的样本进行分类。而在“<strong>无监督学习</strong>”(unsupervised learning)中，训练样本的标记信息是未知的，<strong>目标是</strong>通过对无标记训练样本的学习来揭示数据的内在性质及规律，为进一步的数据分析提供基础。对于无监督学习，应用最广的便是”<strong>聚类</strong>“(clustering)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”<strong>聚类算法</strong>“试图将数据集中的样本划分为若干个通常是不相交的子集，每个子集称为一个“簇”(cluster)，通过这样的划分，每个簇可能对应于一些潜在的概念或类别。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过下面这个图来理解：<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://img-blog.csdnimg.cn/20190724144117607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图是未做标记的样本集，通过他们的分布，我们很容易对上图中的样本做出以下几种划分。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当需要将其划分为两个簇时，即 k=2时：<br><img src="https://img-blog.csdnimg.cn/20190726155350351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当需要将其划分为四个簇时，即 k=4 时：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://img-blog.csdnimg.cn/20190724144431802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<h1 id="二-K-means聚类算法"><a href="#二-K-means聚类算法" class="headerlink" title="二.K-means聚类算法"></a>二.K-means聚类算法</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kmeans算法又名k均值算法,K-means算法中的k表示的是聚类为k个簇，means代表取每一个聚类中数据值的均值作为该簇的中心，或者称为质心，即用每一个的类的质心对该簇进行描述。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其算法思想大致为：先从样本集中随机选取 k个样本作为簇中心，并计算所有样本与这 k个“簇中心”的距离，对于每一个样本，将其划分到与其距离最近的“簇中心”所在的簇中，对于新的簇计算各个簇的新的“簇中心”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据以上描述，我们大致可以猜测到实现kmeans算法的主要四点：<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）簇个数 k 的选择<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）各个样本点到“簇中心”的距离<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）根据新划分的簇，更新“簇中心”<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（4）重复上述2、3过程，直至”簇中心”没有移动<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优缺点：</p>
<ul>
<li>优点：容易实现</li>
<li>缺点：可能收敛到局部最小值，在大规模数据上收敛较慢</li>
</ul>
<h1 id="三-K-means算法步骤详解"><a href="#三-K-means算法步骤详解" class="headerlink" title="三.K-means算法步骤详解"></a>三.K-means算法步骤详解</h1><h2 id="Step1-K值的选择"><a href="#Step1-K值的选择" class="headerlink" title="Step1.K值的选择"></a>Step1.K值的选择</h2><p> k 的选择一般是按照实际需求进行决定，或在实现算法时直接给定 k 值。</p>
<blockquote>
<p>说明：<br> <strong>A</strong>.质心数量由用户给出，记为k，k-means最终得到的簇数量也是k<br> <strong>B</strong>.后来每次更新的质心的个数都和初始k值相等<br> <strong>C</strong>.k-means最后聚类的簇个数和用户指定的质心个数相等，一个质心对应一个簇，每个样本只聚类到一个簇里面<br> <strong>D</strong>.初始簇为空</p>
</blockquote>
<h2 id="Step2-距离度量"><a href="#Step2-距离度量" class="headerlink" title="Step2.距离度量"></a>Step2.距离度量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将对象点分到距离聚类中心最近的那个簇中需要最近邻的度量策略，在欧式空间中采用的是欧式距离，在处理文档中采用的是余弦相似度函数，有时候也采用曼哈顿距离作为度量，不同的情况实用的度量公式是不同的。 </p>
<h3 id="2-1-欧式距离"><a href="#2-1-欧式距离" class="headerlink" title="2.1.欧式距离"></a>2.1.欧式距离</h3><p><img src="https://img-blog.csdnimg.cn/20190724141524460.png" alt></p>
<h3 id="2-2-曼哈顿距离"><a href="#2-2-曼哈顿距离" class="headerlink" title="2.2.曼哈顿距离"></a>2.2.曼哈顿距离</h3><p><img src="https://img-blog.csdnimg.cn/20190724141601149.png" alt></p>
<h3 id="2-3-余弦相似度"><a href="#2-3-余弦相似度" class="headerlink" title="2.3.余弦相似度"></a>2.3.余弦相似度</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A与B表示向量(x1,y1)，(x2,y2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分子为A与B的点乘，分母为二者各自的L2相乘，即将所有维度值的平方相加后开方。<br><img src="https://img-blog.csdnimg.cn/2019072611455719.png" alt></p>
<blockquote>
<p>说明：<br><strong>A</strong>.经过step2，得到k个新的簇，每个样本都被分到k个簇中的某一个簇<br><strong>B</strong>.得到k个新的簇后，当前的质心就会失效，需要计算每个新簇的自己的新质心</p>
</blockquote>
<h2 id="Step3-新质心的计算"><a href="#Step3-新质心的计算" class="headerlink" title="Step3.新质心的计算"></a>Step3.新质心的计算</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于分类后的产生的k个簇，分别计算到簇内其他点距离均值最小的点作为质心（对于拥有坐标的簇可以计算每个簇坐标的均值作为质心）</p>
<blockquote>
<p>说明：<br><strong>A</strong>.比如一个新簇有3个样本：[[1,4], [2,5], [3,6]]，得到此簇的新质心=[(1+2+3)/3,   (4+5+6)/3]<br><strong>B</strong>.经过step3，会得到k个新的质心，作为step2中使用的质心</p>
</blockquote>
<h2 id="Step4-是否停止K-means"><a href="#Step4-是否停止K-means" class="headerlink" title="Step4.是否停止K-means"></a>Step4.是否停止K-means</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;质心不再改变，或给定loop最大次数loopLimit  </p>
<blockquote>
<p>说明：<br><strong>A</strong>当每个簇的质心，不再改变时就可以停止k-menas<br><strong>B</strong>.当loop次数超过looLimit时，停止k-means<br><strong>C</strong>.只需要满足两者的其中一个条件，就可以停止k-means<br><strong>C</strong>.如果Step4没有结束k-means，就再执行step2-step3-step4<br><strong>D</strong>.如果Step4结束了k-means，则就打印(或绘制)簇以及质心</p>
</blockquote>
<h1 id="四-python实现-代码详解"><a href="#四-python实现-代码详解" class="headerlink" title="四.python实现+代码详解"></a>四.python实现+代码详解</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是python得实例代码以及代码的详解，应该可以理解的。</p>
<pre><code>import random
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# 计算欧拉距离
def calcDis(dataSet, centroids, k):
    clalist=[]
    for data in dataSet:
        diff = np.tile(data, (k, 1)) - centroids  #相减   (np.tile(a,(2,1))就是把a先沿x轴复制1倍，即没有复制，仍然是 [0,1,2]。 再把结果沿y方向复制2倍得到array([[0,1,2],[0,1,2]]))
        squaredDiff = diff ** 2     #平方
        squaredDist = np.sum(squaredDiff, axis=1)   #和  (axis=1表示行)
        distance = squaredDist ** 0.5  #开根号
        clalist.append(distance) 
    clalist = np.array(clalist)  #返回一个每个点到质点的距离len(dateSet)*k的数组
    return clalist

# 计算质心
def classify(dataSet, centroids, k):
    # 计算样本到质心的距离
    clalist = calcDis(dataSet, centroids, k)
    # 分组并计算新的质心
    minDistIndices = np.argmin(clalist, axis=1)    #axis=1 表示求出每行的最小值的下标
    newCentroids = pd.DataFrame(dataSet).groupby(minDistIndices).mean() #DataFramte(dataSet)对DataSet分组，groupby(min)按照min进行统计分类，mean()对分类结果求均值
    newCentroids = newCentroids.values

    # 计算变化量
    changed = newCentroids - centroids

    return changed, newCentroids

# 使用k-means分类
def kmeans(dataSet, k):
    # 随机取质心
    centroids = random.sample(dataSet, k)

    # 更新质心 直到变化量全为0
    changed, newCentroids = classify(dataSet, centroids, k)
    while np.any(changed != 0):
        changed, newCentroids = classify(dataSet, newCentroids, k)

    centroids = sorted(newCentroids.tolist())   #tolist()将矩阵转换成列表 sorted()排序

    # 根据质心计算每个集群
    cluster = []
    clalist = calcDis(dataSet, centroids, k) #调用欧拉距离
    minDistIndices = np.argmin(clalist, axis=1)  
    for i in range(k):
        cluster.append([])
    for i, j in enumerate(minDistIndices):   #enymerate()可同时遍历索引和遍历元素
        cluster[j].append(dataSet[i])

    return centroids, cluster

# 创建数据集
def createDataSet():
    return [[1, 1], [1, 2], [2, 1], [6, 4], [6, 3], [5, 4]]

if __name__==&#39;__main__&#39;: 
    dataset = createDataSet()
    centroids, cluster = kmeans(dataset, 2)
    print(&#39;质心为：%s&#39; % centroids)
    print(&#39;集群为：%s&#39; % cluster)
    for i in range(len(dataset)):
      plt.scatter(dataset[i][0],dataset[i][1], marker = &#39;o&#39;,color = &#39;green&#39;, s = 40 ,label = &#39;原始点&#39;)
                                                    #  记号形状       颜色      点的大小      设置标签
      for j in range(len(centroids)):
        plt.scatter(centroids[j][0],centroids[j][1],marker=&#39;x&#39;,color=&#39;red&#39;,s=50,label=&#39;质心&#39;)
        plt.show
</code></pre><h1 id="五-K-means算法补充"><a href="#五-K-means算法补充" class="headerlink" title="五.K-means算法补充"></a>五.K-means算法补充</h1><p>1.对初始化敏感，初始质点k给定的不同，可能会产生不同的聚类结果。如下图所示，右边是k=2的结果，这个就正好，而左图是k=3的结果，可以看到右上角得这两个簇应该是可以合并成一个簇的。</p>
<p>改进：<br>对k的选择可以先用一些算法分析数据的分布，如重心和密度等，然后选择合适的k<br><img src="https://img-blog.csdnimg.cn/20190726154810167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>2.<strong>使用存在局限性</strong>，如下面这种非球状的数据分布就搞不定了：<br><img src="https://img-blog.csdnimg.cn/20190724161221112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>3.数据集比较大的时候，<strong>收敛会比较慢</strong>。</p>
<p>4.最终会收敛。不管初始点如何选择，最终都会收敛。可是是全局收敛，也可能是局部收敛。</p>
<h1 id="六-小结"><a href="#六-小结" class="headerlink" title="六.小结"></a>六.小结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 聚类是一种无监督的学习方法。聚类区别于分类，即事先不知道要寻找的内容，没有预先设定好的目标变量。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 聚类将数据点归到多个簇中，其中相似的数据点归为同一簇，而不相似的点归为不同的簇。相似度的计算方法有很多，具体的应用选择合适的相似度计算方法</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. K-means聚类算法，是一种广泛使用的聚类算法，其中k是需要指定的参数，即需要创建的簇的数目，K-means算法中的k个簇的质心可以通过随机的方式获得，但是这些点需要位于数据范围内。在算法中，计算每个点到质心得距离，选择距离最小的质心对应的簇作为该数据点的划分，然后再基于该分配过程后更新簇的质心。重复上述过程，直至各个簇的质心不再变化为止。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. K-means算法虽然有效，但是容易受到初始簇质心的情况而影响，有可能陷入局部最优解。为了解决这个问题，可以使用另外一种称为二分K-means的聚类算法。二分K-means算法首先将所有数据点分为一个簇；然后使用K-means（k=2）对其进行划分；下一次迭代时，选择使得SSE下降程度最大的簇进行划分；重复该过程，直至簇的个数达到指定的数目为止。实验表明，二分K-means算法的聚类效果要好于普通的K-means聚类算法。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>K-means</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2019/03/15/hexo-bo-ke-da-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇文章用于介绍Hexo个人博客的搭建过程，这也是我搭建本博客后的第一篇文章，分享一下搭建方法，有兴趣的小伙伴也可以自主搭建一个属于自己的博客！<br>   首先<strong>感谢大家的来访支持</strong>！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自己本来开始做的是html网页，网页做完之后需要购买服务器和域名（价格不便宜）才能运营，还要定期维护它，对于我个人只是感兴趣做个自己的网页，单单做个html网页就很费力气了，实在是没有精力和时间运营它，所以也没有必要去购买服务器和域名（性价比低），但我做的html网页在我自己的电脑上还是可以运营的（感兴趣的小伙伴可以联系我，一起探讨做html网页的方法）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，现在市面上的博客有很多，如CSDN，博客园等平台，可以直接在上面发表，也有很多优点，但缺点是比较不自由，会受到各种限制和恶心的广告。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我选择了直接在github page平台上托管我的博客，这样可以安心写作，也不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客也很简单。我在两天内完成了Hexo-Github个人博客的基本搭建（其实搭建不难，自己脑子笨，做的慢些了……）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里记录一下我的第搭建一个博客，并给大家分享一下搭建的流程，以及在搭建过程中遇到的问题和解决方案。如果你也有搭建个人博客的想法，希望能给你一点经验帮助。 大家都是新手，可以分享经验，互相交流学习的。</p>
<h2 id="搭建经历"><a href="#搭建经历" class="headerlink" title="搭建经历"></a>搭建经历</h2><ul>
<li>❤2019-3-13：初次看到Hexo-Github搭建个人博客，很感兴趣，便开始了自己博客的搭建；</li>
<li>❤2019-3-14：完成了博客的基本搭建（可以运营），并上传了第一篇文章； </li>
<li>❤2019-3-17：博客搭建工作全部完结（主题优化，程序添加，分类管理……）;</li>
<li>❤未完待续……</li>
</ul>
<h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><pre><code>1. 安装Git
2. 安装Node.js
3. 安装Hexo
4. 注册Github账号并创建新仓库
5. 生产SSH添加到Github
6. 将Hexo部署到Github
7. 修改主题
8. 优化主题
</code></pre><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接到<a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网</a>下载就行了，右键点击软件使用Git Bash的命令行工具，以后就用这个工具来使用Git</p>
<h3 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装同Git一样，也是到<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网</a>下载就可以了。</p>
<h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用下载好的Git Bash来下载Hexo，代码如下：</p>
<pre><code> npm install hexo-cli -g
</code></pre><h3 id="4-注册Github账号并创建一个新的仓库"><a href="#4-注册Github账号并创建一个新的仓库" class="headerlink" title="4.注册Github账号并创建一个新的仓库"></a>4.注册Github账号并创建一个新的仓库</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/" target="_blank" rel="noopener">Github</a>是一个很好的开源项目托管平台，大部分人应该都注册的有账号（有账号的小伙伴可以跳过这步），即使没有注册过也没有关系，只需现在注册下就行了，请参考<a href="https://www.jianshu.com/p/f51062941573" target="_blank" rel="noopener">Github基础设置及使用详解</a>，里面的有详细的注册过程,过程也很简单。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册过账号后，先创建一个新的仓库（创建的具体方法上面的那个网站也有详细过程，但这里需要注意的是，创建的仓库名一定要是 <code>name.github.io</code>,其中name为你注册的Github的用户名，修改成你自己的。</p>
<h3 id="5-生成SSH添加到Github"><a href="#5-生成SSH添加到Github" class="headerlink" title="5.生成SSH添加到Github"></a>5.生成SSH添加到Github</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先配置SSH，同样使用Git Bash,输入一下代码：</p>
<pre><code> ssh-keygen -t rsa -C &quot;邮件地址&quot;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中”邮件地址”是你注册Github时填写的邮箱（输入时双引号要带上），输入后要连续按回车键，再等待回应。它会回复：</p>
<pre><code>Enter file in which to save the key (/c/Users/lenovo/.ssh/id_rsa):

</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后进入<code>(/c/Users/lenovo/.ssh/id_rsa.pub)</code>,将里面的内容复制下来，再进入Github官网，到GitHub设置-&gt;SSH and GPG keys-&gt;New SSH key，粘贴此处并确定。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再回到Git Bash,输入一下代码：</p>
<pre><code>ssh -T git@github.com
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于测试SSH是否配置好，看到<code>You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>则说明配置好了，否则无法使用hexo d。</p>
<h3 id="6-将Hexo部署到Github"><a href="#6-将Hexo部署到Github" class="headerlink" title="6. 将Hexo部署到Github"></a>6. 将Hexo部署到Github</h3><h4 id="nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-初始化Hexo"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-初始化Hexo" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化Hexo"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化Hexo</h4><pre><code>hexo init Blog                    
cd Blog    
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blog可修该城其他名字；cd Blog 指打开Blog文件夹。</p>
<h4 id="nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-安装Hexo扩展"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-安装Hexo扩展" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装Hexo扩展"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装Hexo扩展</h4><pre><code>npm install hexo-deployer-git --save
npm install
</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-本地调试"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-本地调试" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本地调试"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本地调试</h4><pre><code>hexo clean
hexo g                        
hexo s                        

</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexo s是开启本地预览服务，打开浏览器访问<a href="http://localhost:4000" target="_blank" rel="noopener"> http://localhost:4000</a> 即可看到内容。</p>
<h4 id="nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-上传到Github-Pages"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-上传到Github-Pages" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上传到Github Pages"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上传到Github Pages</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上传之前，打开站点配置文件_config.yml，位于站点根目录下，修改最后一部分为如下部分。</p>
<pre><code>deploy:
  type: git
  repository: git@github.com:name/name.github.io.git    #name修改为你的Github用户名
  branch: master
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上传到Github</p>
<pre><code>hexo clean
hexo g                        
hexo d
</code></pre><h3 id="7-修改主题"><a href="#7-修改主题" class="headerlink" title="7.修改主题"></a>7.修改主题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主题位置在themes目录下，默认为landscape主题。可从官网<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a>选择各种下载（得看个人喜好了），推荐NexT主题，以下为安装方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装过程就一行代码，站点根目录下运行。</p>
<pre><code>git clone https://github.com/theme-next/hexo-theme-next themes/next
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后打开站点配置文件_config.yml，找到theme： landscape，把landscape修改为next就可以了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到现在你就已经搭建好了一个属于你自己的博客平台了，赶紧去熟悉熟悉它吧。👍</p>
<h3 id="8-主题优化"><a href="#8-主题优化" class="headerlink" title="8.主题优化"></a>8.主题优化</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实刚才我们已经搭建好了，并且也可以使用了，但我们仍可以使我们的博客变得更加好看吸引人，以及添加更多的小功能，使我们有更好的体验，也就是进行主题优化。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但由于主题优化内容比较多，所以在这就先不讲解了，不用担心，我会在后续的博客文章中持续更新关于如何进行主题优化，使我们的博客变得“高大上”。🤞</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>KNN算法及python实现</title>
    <url>/2019/07/20/k-zui-jin-lin-fen-lei-suan-fa-knn-ji-python-shi-xian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KNN算法即K-Nearest Neighbor，也是机器学习十大经典算法之一。前文讲解了K-means算法，今天我们就继续讲KNN算法，两者看起来挺相似的，但区别还是很大的，看完本片文章你就会明白了。</p>
<h1 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h1><p>问题：确定绿色圆是属于红色三角形、还是蓝色正方形？<br><img src="https://img-blog.csdnimg.cn/20190729110829508.png" alt><br>KNN的思想：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图中我们可以看到，图中的数据集是良好的数据，即都打好了label，一类是蓝色的正方形，一类是红色的三角形，那个绿色的圆形是我们待分类的数据。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果K=3，那么离绿色点最近的有2个红色三角形和1个蓝色的正方形，这3个点投票，于是绿色的这个待分类点属于红色的三角形<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果K=5，那么离绿色点最近的有2个红色三角形和3个蓝色的正方形，这5个点投票，于是绿色的这个待分类点属于蓝色的正方形<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即如果一个样本在特征空间中的k个最相邻的样本中，大多数属于某一个类别，则该样本也属于这个类别。我们可以看到，KNN本质是基于一种数据统计的方法！其实很多机器学习算法也是基于数据统计的。</p>
<h1 id="二、KNN算法"><a href="#二、KNN算法" class="headerlink" title="二、KNN算法"></a>二、KNN算法</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KNN即K-最近邻分类算法（K-Nearest Neighbor），是一种memory-based learning，也叫instance-based learning，属于lazy learning。即它没有明显的前期训练过程，而是程序开始运行时，把数据集加载到内存后，不需要进行训练，就可以开始分类了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KNN也是一种监督学习算法，通过计算新数据与训练数据特征值之间的距离，然后选取K(K&gt;=1)个距离最近的邻居进行分类判(投票法)或者回归。若K=1，新数据被简单分配给其近邻的类。</p>
<h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2.步骤"></a>2.步骤</h2><p>1）计算测试数据与各个训练数据之间的距离；</p>
<blockquote>
<p>(计算距离的方式前文讲k-means时说过，不清楚的可以去查看以下➡<a href="https://hpu-yz.github.io/2019/07/19/K-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/">传送门</a>)</p>
</blockquote>
<p>2）按照距离的递增关系进行排序；</p>
<p>3）选取距离最小的K个点；</p>
<blockquote>
<p>K值是由自己来确定的</p>
</blockquote>
<p>4）确定前K个点所在类别的出现频率；</p>
<p>5）返回前K个点中出现频率最高的类别作为测试数据的预测分类。</p>
<blockquote>
<p>说明：对于步骤5的预测分类有以下两种方法</p>
<ol>
<li>多数表决法：多数表决法类似于投票的过程，也就是在 K 个邻居中选择类别最多的种类作为测试样本的类别。</li>
<li>加权表决法：根据距离的远近，对近邻的投票进行加权，距离越近则权重越大，通过权重计算结果最大值的类为测试样本的类别。</li>
</ol>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1)  非参数统计方法：不需要引入参数<br>2)  K的选择：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K = 1时，将待分类样本划入与其最接近的样本的类。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K = |X|时，仅根据训练样本进行频率统计，将待分类样本划入最多的类。<br>K需要合理选择，太小容易受干扰，太大增加计算复杂性。<br>3)  算法的复杂度：维度灾难，当维数增加时，所需的训练样本数急剧增加，一般采用降维处理。</p>
<h1 id="三、算法优缺点"><a href="#三、算法优缺点" class="headerlink" title="三、算法优缺点"></a>三、算法优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>简单、有效。 </li>
<li>重新训练的代价较低(类别体系的变化和训练集的变化，在Web环境和电子商务应用中是很常见的)。 </li>
<li>计算时间和空间线性于训练集的规模(在一些场合不算太大)。 </li>
<li>由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。 </li>
<li>该算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分。 </li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>KNN算法是懒散学习方法(lazy learning)，而一些积极学习的算法要快很多。 </li>
<li>需要存储全部的训练样本 </li>
<li>输出的可解释性不强，例如决策树的可解释性较强。 </li>
<li>该算法在分类时有个主要的不足是，当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。该算法只计算最近的邻居样本，某一类的样本数量很大，那么或者这类样本并不接近目标样本，或者这类样本很靠近目标样本。无论怎样，数量并不能影响运行结果。可以采用权值的方法(和该样本距离小的邻居权值大)来改进。 </li>
<li>计算量较大。目前常用的解决方法是事先对已知样本点进行剪辑，事先去除对分类作用不大的样本。</li>
</ol>
<h1 id="四、KNN与K-means的区别"><a href="#四、KNN与K-means的区别" class="headerlink" title="四、KNN与K-means的区别"></a>四、KNN与K-means的区别</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;废话不多说，咱直接上图：<br><img src="https://img-blog.csdnimg.cn/2019072911370194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>相似点：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然两者有很大且别，但两者也有共同之处。都包含了一个过程：给定一个点，在数据集找离它最近的点，即都用到了NN(Nearest Neighbor)算法。</p>
<h1 id="五、python实例实现"><a href="#五、python实例实现" class="headerlink" title="五、python实例实现"></a>五、python实例实现</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面引入一个实例，通过python代码具体看下KNN算法的流程。</p>
<pre><code>from numpy import *
import operator

dataSet = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]])
labels = [&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;B&#39;]

def classify0(inX,dataSet,labels,k):

    #求出样本集的行数，也就是labels标签的数目
    dataSetSize = dataSet.shape[0]

    #构造输入值和样本集的差值矩阵
    diffMat = tile(inX,(dataSetSize,1)) - dataSet

    #计算欧式距离
    sqDiffMat = diffMat**2
    sqDistances = sqDiffMat.sum(axis=1)
    distances = sqDistances**0.5

    #求距离从小到大排序的序号
    sortedDistIndicies = distances.argsort()

    #对距离最小的k个点统计对应的样本标签
    classCount = {}
    for i in range(k):
        #取第i+1邻近的样本对应的类别标签
        voteIlabel = labels[sortedDistIndicies[i]]
        #以标签为key，标签出现的次数为value将统计到的标签及出现次数写进字典
        classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1

    #对字典按value从大到小排序
    sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True)

    #返回排序后字典中最大value对应的key
    return sortedClassCount[0][0]
if __name__ == &#39;__main__&#39;:
    print(classify0([1.1,0],dataSet,labels,3))
</code></pre>]]></content>
      <categories>
        <category>机器学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Python判断合式公式</title>
    <url>/2019/03/17/python-pan-duan-chi-san-shu-xue-de-he-shi-gong-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你没有听错，用python程序来解决离散数学的逻辑推理问题，我当我第一次听老师说的时候也很吃惊（再说上学期的Python学的也不咋地…..😩)，但经老师讲解后才知道，使用python解题不仅效率高，而且准确性也很强的，所以还是有必要学习一下的。</p>
<h2 id="判断是否为合式公式"><a href="#判断是否为合式公式" class="headerlink" title="判断是否为合式公式"></a>判断是否为合式公式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个题目就是判断一个公式是否为合式公式，这也是最基础的，因为只有当在输入的合式公式正确的情况下，才能进一步的运算解题，所以先讲解一下怎么判断合式公式。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先要知道<strong>什么是合式公式</strong>？<br>(1)原子命题常项或变项是合式公式；<br>(2)如果A是合式公式，则（-A）也是合式公式（- 表示非）；<br>(3)如果A，B是合式公式，则（A<em>B）、（A+B）、（A &lt; B）、（ A ~ B）也是合式公式；(此处 </em> 合取 + 析取 &lt; 代表条件 ~ 代表双条件)<br>(4)只有有限次地应用(1)～(3)所包含的命题变元，联结词和括号的符号串才是合式公式。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>个人思路</strong>：<br>输入字符串，扫描字符串，把所含的各关联词分区出来，在判断每个关联词使用是否正确<br>比如不合规则的情况：<br>(1) 关联词所处位置不对<br>(2) 关联词的连续使用<br>(3) 括号不匹配<br>(4) ……..<br>程序中可能会有bug，希望大佬们多多指教</p>
<h2 id="这道题应该有很多好的方法，但我不太会用，我这里只能暴力判断了。"><a href="#这道题应该有很多好的方法，但我不太会用，我这里只能暴力判断了。" class="headerlink" title="这道题应该有很多好的方法，但我不太会用，我这里只能暴力判断了。"></a>这道题应该有很多好的方法，但我不太会用，我这里只能暴力判断了。</h2><h4 id="废话不多说，直接上代码😎"><a href="#废话不多说，直接上代码😎" class="headerlink" title="废话不多说，直接上代码😎"></a>废话不多说，直接上代码😎</h4><pre><code>import re
print(&quot;定义‘!’为否定联结词&quot;)
print(&quot;定义‘&amp;’为合取联结词&quot;)
print(&quot;定义‘-’为析取联结词&quot;)
print(&quot;定义‘&gt;’为蕴含联结词&quot;)
print(&quot;定义‘~’为等价联结词&quot;)
print(&quot;如果公式错误，会指出哪里错误；如果公式正确，则什么也不输出&quot;)
S =input(&quot;请输入需要判断的公式：&quot;)
T = list(S)
if S[0] in [&#39;&amp;&#39;,&#39;-&#39;,&#39;)&#39;,&#39;~&#39;,&#39;&gt;&#39;] :
    print(&quot;不是合式公式&quot;)
a ,b,c,d,f =&quot;!&quot; , &quot;&amp;&quot; ,&quot;-&quot; , &quot;&gt;&quot; , &quot;~&quot;
if a in T:
        Q = [m.start() for m in re.finditer(a, S)]
        for i in Q :
            if S[-1] == &#39;!&#39; :
                print (&quot;‘!’联结词使用错误，不是合式公式&quot;)
                break
            if S[i+1] in [&#39;&amp;&#39;,&#39;!&#39;,&#39;-&#39;,&#39;)&#39;,&#39;~&#39;,&#39;&gt;&#39;]:
                print(&quot;‘!’联结词使用错误，不是合式公式&quot;)
                break
            if S[i-1] in [&#39;!&#39;]:
                print(&quot;‘!’联结词使用错误，不是合式公式！&quot;)
                break
if b in T:
        W = [m.start() for m in re.finditer(b, S)]
        for y in W :
            if S[-1] == &#39;&amp;&#39; :
                print (&quot;‘&amp;’联结词使用错误，不是合式公式&quot;)
                break
            if S[y+1] in [&#39;-&#39;,&#39;)&#39;,&#39;~&#39;,&#39;&gt;&#39;,&#39;&amp;&#39;] :
                print(&quot;‘&amp;’联结词使用错误，不是合式公式&quot;)
                break
            if S[y-1] in [&#39;-&#39;,&#39;(&#39;,&#39;~&#39;,&#39;&gt;&#39;,&#39;&amp;&#39;] :
                print(&quot;‘&amp;’联结词使用错误，不是合式公式&quot;)
                break
if c in T:
        E = [m.start() for m in re.finditer(c, S)]
        for h in E :
            if S[-1] == &#39;-&#39; :
                print(&quot;‘-’联结词使用错误，不是合式公式&quot;)
                break
            if S[h+1] in (&#39;)&#39;,&#39;&gt;&#39;,&#39;~&#39;,&#39;-&#39;) :
                print(&quot;‘-’联结词使用错误，不是合式公式&quot;)
                break
            if S[h-1] in (&#39;&amp;&#39;,&#39;-&#39;,&#39;&gt;&#39;,&#39;~&#39;) :
                print(&quot;‘-’联结词使用错误，不是合式公式&quot;)
                break
if d in T:
        R = [m.start() for m in re.finditer(d, S)]
        for k in R :
            if S[-1] == &#39;&gt;&#39; :
                print (&quot;‘&gt;’联结词使用错误，不是合式公式&quot;)
                break
            if S[k+1] in [&#39;)&#39;,&#39;&gt;&#39;] :
                print(&quot;‘&gt;’联结词使用错误，不是合式公式&quot;)
                break
            if S[k-1] in  [&#39;(&#39;,&#39;&gt;&#39;] :
                print(&quot;‘&gt;’联结词使用错误，不是合式公式&quot;)
                break
if f in T:
        O = [m.start() for m in re.finditer(f, S)]
        for v in O :
            if S[-1] == &#39;~&#39; :
                print(&quot;‘~’联结词使用错误，不是合式公式&quot;)
                break
            if S[v+1] in [&#39;)&#39;,&#39;~&#39;] :
                print(&quot;‘~’联结词使用错误，不是合式公式&quot;)
                break
            if S[v-1] in [&#39;(&#39;,&#39;~&#39;] :
                print(&quot;‘~’联结词使用错误，不是合式公式&quot;)
                break
if &#39;(&#39; or &#39;)&#39; in S :
        e = 0
        klb =[]
        for i in S :
            if i == &#39;(&#39;:
                klb.append(i)
            if i == &#39;)&#39;:
                if len(klb)==0:
                    e=1
                    break
                else :
                    klb.pop()
        if len(klb)!=0 :
            e = 1
        if e==1:
            print(&quot;括号使用错误，不是合式公式&quot;)


</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我也是小白，程序哪里可能有些不足之处，请多多指教，如果你有更好的解题方法或思路，可以联系我，大家可以一起学习，一起进步的！😊</p>
]]></content>
      <categories>
        <category>python</category>
        <category>离散</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>离散</tag>
      </tags>
  </entry>
  <entry>
    <title>while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</title>
    <url>/2019/03/21/oj/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“测试输入包含若干测试实例。当N为0时，输入结束，该实例不被处理。”这句话 是最早我对OJ的印象 以前也没见过这种输入要求， 做第一道题的时候就卡住了 上网看别人的代码 都有一句 while(scanf(“%d”,&amp;n)!=EOF)”scanf 函数还能放while里啊… EOF是什么玩意儿呢…”</p>
<blockquote>
<h2 id="什么是OJ？"><a href="#什么是OJ？" class="headerlink" title="什么是OJ？"></a>什么是OJ？</h2></blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先先介绍下什么是OJ吧(知道的同学可以跳过此部分)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Online Judge系统（简称OJ）是一个在线的判题系统。用户可以在线提交程序多种程序（如C、C++）源代码，系统对源代码进行编译和执行，并通过预先设计的测试数据来检验程序源代码的正确性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个用户提交的程序在Online Judge系统下执行时将受到比较严格的限制，包括运行时间限制，内存使用限制和安全限制等。用户程序执行的结果将被Online Judge系统捕捉并保存，然后再转交给一个裁判程序。该裁判程序或者比较用户程序的输出数据和标准输出样例的差别，或者检验用户程序的输出数据是否满足一定的逻辑条件。最后系统返回给用户一个状态：通过（Accepted,AC）、答案错误(Wrong Answer,WA)、超时(Time Limit Exceed,TLE)、超过输出限制（Output Limit Exceed,OLE)、超内存（Memory Limit Exceed,MLE）、运行时错误（Runtime Error,RE）、格式错误（Presentation Error,PE)、或是无法编译（Compile Error,CE），并返回程序使用的内存、运行时间等信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Online Judge系统最初使用于ACM-ICPC国际大学生程序设计竞赛和OI信息学奥林匹克竞赛中的自动判题和排名。现广泛应用于世界各地高校学生程序设计的训练、参赛队员的训练和选拔、各种程序设计竞赛以及数据结构和算法的学习和作业的自动提交判断中。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;知名的OJ有：RQNOJ,URAL,SPOJ,vijos,tyvj,USACO,sgu,pku(poj),zju(toj),tju,uva，HDU(HDOJ)等。</p>
<blockquote>
<h2 id="EOF是什么东东？"><a href="#EOF是什么东东？" class="headerlink" title="EOF是什么东东？"></a>EOF是什么东东？</h2></blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EOF 是一个宏 ，一般定义为-1。<br>1.EOF用来判断文件结束的标记(end of file) 用在文件操作中,可以查下msdn 看它的定义:EOF is returned by       an I/O routine when the end-of-file (or in some cases, an error) is encountered<br>2.EOF表示输入流的结束。<br>3.在发送端套接字关闭后，接收端读套接字的read函数也会返回EOF.</p>
<blockquote>
<h2 id="while-scanf-EOF-流程图"><a href="#while-scanf-EOF-流程图" class="headerlink" title="while(scanf()!=EOF)流程图"></a>while(scanf()!=EOF)流程图</h2></blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们学过的有三种循环：for，while，do-while。但while (scanf(“%d”, &amp;n) != EOF)不像以上的任何一种，接下来看一下它的流程图：<br><img src="/2019/03/21/oj/while-1/20140502221756328.png" alt="流程图"></p>
<blockquote>
<h2 id="OnlineJuge的评判时，该语句的作用"><a href="#OnlineJuge的评判时，该语句的作用" class="headerlink" title="OnlineJuge的评判时，该语句的作用"></a>OnlineJuge的评判时，该语句的作用</h2></blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OJ评判的原理应该是这样的：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入：通过管道命令，将一个包含若干测试用例的文件作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为【标准输入流】，所以需要while(scanf() != EOF)来判断测试文件是否读完。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出：通过管道命令，将【标准输出流】，输出到一个文件中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;评判：将程序的【输出文件】与【正确答案文件】进行比对：如果一样，则返回程序正确提示；否则返回程序错误的提示。</p>
<blockquote>
<h2 id="使用原理"><a href="#使用原理" class="headerlink" title="使用原理"></a>使用原理</h2></blockquote>
<p>有人说 EOF等于-1 其实就是scanf函数的返回值 不等于-1时 继续进行循环</p>
<p>有人说 EOF是处理到文件结束 不用EOF也可以</p>
<p>……….</p>
<p>很多天后终于把这个弄明白了</p>
<p>scanf的返回值由后面的参数决定</p>
<p>scanf(“%d%d”, &amp;a, &amp;b);</p>
<p>如果a和b都被成功读入，那么scanf的返回值就是2</p>
<p>如果只有a被成功读入，返回值为1</p>
<p>如果a和b都未被成功读入，返回值为0</p>
<p>如果遇到错误或遇到end of file，返回值为EOF，且返回值为int型.</p>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上是我个人所述，若有什么不对的地方或者有补充的地方，还希望各位指点指点，大家可以一起学习，一起进步！</p>
]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Python+离散数学→逻辑演算</title>
    <url>/2019/04/02/python-chi-san-shu-xue-luo-ji-yan-suan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇探讨的是一道逻辑演算推理题。有两种方法，一种是常规的离散数学逻辑演算，另一种则是用python程序来解决。本篇将探究两种方法： python+离散数学→逻辑演算。</p>
<blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在某次研讨会的中间休息时间，3名与会者根据王教授的口音对他是哪个省市的人判断如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;甲:王教授不是苏州人，是上海人<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乙:王教授不是上海人，是苏州人<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;丙:王教授既不是上海人，也不是杭州人<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;听完这3人的判断后，王教授笑着说，你们3人中有一人说得全对，有一人说对了一半，另一人全不对。试用逻辑演算分析王教授到底是哪里人.</p>
</blockquote>
<blockquote>
<h2 id="常规推理"><a href="#常规推理" class="headerlink" title="常规推理"></a>常规推理</h2></blockquote>
<p>设命题&nbsp;&nbsp;&nbsp;&nbsp;p:王教授是苏州人；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q:王教授是上海人；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r:王教授是杭州人；</p>
<p>用p,q,r表示甲乙丙的观点如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;甲：￢p∧q</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乙：p∧￢q</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;丙：￢q∧￢r              </p>
<p>其中一人全对，一人对一半，另一人全错。</p>
<p>即其中一个真命题，两个假命题。先找真命题</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;甲全对：B1=￢p∧q</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;甲对一半：B2=(￢p∧￢q) ∨(p∧q)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;甲全错：B3=p∧￢q</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乙全对：C1= p∧￢q</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乙对一半：C2=(￢p∧￢q) ∨(p∧q)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乙全错：C3=￢p∧q</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;丙全对：D1=￢q∧￢r</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;丙对一半：D2=(q∧￢r) ∨( ￢q∧r)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;丙全错：D3=q∧r</p>
<p>有王教授那句话可以写：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E=（B1∧C2∧D3）∨(B1∧C3∧D2) ∨(B2∧C1∧D3) ∨(B2∧C3∧D1) ∨(B3∧C1∧D2) ∨(B3∧C2∧D1)</p>
<p>是真命题</p>
<p>而B1∧C2∧D3⇔(￢p∧q) ∧((￢p∧￢q) ∨(p∧q)) ∧(q∧r)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔(￢p∧q) ∧((￢p∧￢q) ∧(q∧r) ∨ (p∧q) ∧(q∧r))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔(￢p∧q) ∧(0∨(p∧q∧r))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔(￢p∧q)∧(p∧q∧r)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔0</p>
<p>其他同理类似可得：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B1C3D2⇔￢p∧q∧￢r</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B2C1D3⇔0</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B2C3D1⇔0</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B3C1D2⇔p∧￢q∧r</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B3C2D1⇔0</p>
<p>所以E⇔(￢p∧q∧￢r) ∨(p∧￢q∧r)</p>
<p>而pqr中只能有一个是真的，所以p∧q⇔0，p∧r⇔0，q∧r⇔0</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E⇔(￢p∧q∧￢r) ∨0</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔￢p∧q∧￢r</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔1</p>
<p>所以p为假，q为真，r为假，王教授是上海人。</p>
<blockquote>
<h2 id="python程序实现"><a href="#python程序实现" class="headerlink" title="python程序实现"></a>python程序实现</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是上述过程的代码实现，并附有代码详解，有兴趣的小伙伴可以看一看。</p>
</blockquote>
<pre><code>for p in range(2):                                  #p:王教授是苏州人
    for q in range(2):                              #q:王教授是上海人
        for r in range(2):                          #r:王教授是杭州人
         #以下三行表示p,q,r不可能同时为真的情况
         if (p == 1 and q == 1): continue
         if (p == 1 and r == 1): continue
         if (q == 1 and r == 1): continue

         Jia = (not p) and q                        #甲的判断
         Yi = p and (not q)                         #乙的判断
         Bing = (not q) and (not r)                 #丙的判断

         B1 = (not p) and q                         #甲的判断全对
         B2 = ((not p) and (not q))or (p and q)     #甲的判断一半对
         B3 = p and (not q)                         #甲的判断全错

         C1 = p and (not q)                         #乙的判断全对
         C2 = (p and q) or ((not p) and (not q))    #乙的判断一半对
         C3 = (not p) and q                         #乙的判断全错

         D1 = (not q) and (not r)                   #丙的判断全对
         D2 = ((not q) and r) or (q and(not r))     #丙的判断一半对
         D3 = q and r                               #丙的判断全错

         #王教授所说的话
         E = (B1 and C2 and D3) \
           or(B1 and C3 and D2) \
           or(B2 and C1 and D3) \
           or(B2 and C3 and D1) \
           or(B3 and C1 and D2) \
           or(B3 and C2 and D1)

         #符合王教授所的E值
         if E==1 :
           print(&quot;%d,%d,%d E=%d,Jia=%d,Yi=%d,Bing=%d&quot;%(p,q,r,E,Jia,Yi,Bing))


</code></pre><blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实用python解决离散数学的逻辑推理题比直接推理效率更高而且准确性也高，并且在遇到复杂的逻辑推理时，很容易把自己绕晕，半天也解不出来，倒不如我们可以让计算机帮我们解决，只需写几十行代码，就可以罗列出复杂的关系，何乐而不为呢，所以我们可以多学学这种解题方法！😁</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
        <category>离散</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>离散</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫~豆瓣电影排行榜</title>
    <url>/2020/03/20/python-pa-chong-pa-qu-dou-ban-top250-dian-ying-pai-xing-bang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本篇讲介绍一个简单的Python爬虫案例–爬取豆瓣 TOP250 电影排行榜。</p>
<p>很多朋友在看一部电影前都喜欢先找一下网友们对该片的评价。</p>
<p>说到电影评分的网站，除了国外的 IMDB 和烂番茄，国内要数豆瓣最为出名。</p>
<p>主要原因是豆瓣有一套完整的评分和防水军机制 。</p>
<p>在这套机制下，豆瓣评分高的电影不一定是所有人都喜欢的，但是豆瓣评分低的电影，一定是实打实的烂片！</p>
<p>虽然每个人的喜好偏爱不同，但通常豆瓣评分 8 分以上的电影，都是值得一看的。</p>
<p>豆瓣还专门提供了一个 TOP250 的电影链接 -&gt; <a href="https://movie.douban.com/top250" target="_blank" rel="noopener">https://movie.douban.com/top250</a></p>
<h1 id="爬取思路"><a href="#爬取思路" class="headerlink" title="爬取思路"></a>爬取思路</h1><p>爬取的过程很好理解，这里只需要两个过程：<br>① 从服务器上下载所需页面<br>② 解析这个页面，得到自己需要有用的内容</p>
<h3 id="①抓取页面"><a href="#①抓取页面" class="headerlink" title="①抓取页面"></a>①抓取页面</h3><p>有的人可能会利用 urllib 模块实现网络抓取功能。但在 Python 中，有一个更好地替代者——Requests。Requests 简化了 urllib 的诸多冗杂且无意义的操作，并提供了更强大的功能。<br>所以在这里我们使用 Requests 模块的 get() 方法从服务器上来下载这个页面。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> requests

url <span class="token operator">=</span> <span class="token string">"https://movie.douban.com/top250"</span>
headers <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">"User-Agent"</span><span class="token punctuation">:</span><span class="token string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3314.0 Safari/537.36 SE 2.X MetaSr 1.0"</span>
    <span class="token punctuation">}</span>

res <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>res就是我们需要的这个页面的资源，我们不妨打开来看看是不是</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"豆瓣电影.txt"</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>打开文本如下图<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zbG9tb28ub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzJkZTI1MDMzZTQ0NGY3NTc2ZTRlNDZlYmU2Mjg1YzllLm1kLnBuZw?x-oss-process=image/format,png" alt><br>我们可以看出这确实是当前网页的资源，所以我们就抓取成功了。</p>
<h2 id="②解析页面"><a href="#②解析页面" class="headerlink" title="②解析页面"></a>②解析页面</h2><p>解析网页内容推荐使用 BeautifulSoup 模块，它可以化腐朽为神奇，将一个复杂的网页结构转化为书籍目录的形式供你浏览。<br>例如，我们现在需要解析提取出当前页面的电影名字</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> bs4
soup <span class="token operator">=</span> bs4<span class="token punctuation">.</span>BeautifulSoup<span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">"html.parser"</span><span class="token punctuation">)</span>
targets <span class="token operator">=</span> soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">"hd"</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> each <span class="token keyword">in</span> targets<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>each<span class="token punctuation">.</span>a<span class="token punctuation">.</span>span<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以得到如下结果</p>
<blockquote>
<p>肖申克的救赎<br>霸王别姬<br>阿甘正传<br>这个杀手不太冷<br>美丽人生<br>泰坦尼克号<br>千与千寻<br>辛德勒的名单<br> 盗梦空间<br> 忠犬八公的故事<br> 海上钢琴师<br>机器人总动员<br>三傻大闹宝莱坞<br>楚门的世界<br>放牛班的春天<br> 星际穿越<br> 大话西游之大圣娶亲<br> 熔炉<br> 疯狂动物城<br> 无间道<br> 龙猫<br> 教父<br> 当幸福来敲门<br>怦然心动<br>触不可及</p>
</blockquote>
<p>这里你可能就会有疑问，这些数据是怎么得来的呢？<br>我们先来看下 HTML 源代码：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zbG9tb28ub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2E0MDcxYzNhNmYyZDUzMjVjMWJhYzJhMDQ4OTQ2Zjk4Lm1kLnBuZw?x-oss-process=image/format,png" alt><br>发现每个电影的标题都是位于 <code>&lt;div class=&quot;hd&quot;&gt;...&lt;/div&gt;</code> 标签中的，它的从属关系是：<code>div -&gt; a -&gt; span</code>。</p>
<p>所以我们先调用 find_all() 方法，找到所有 class=”hd” 的 div 标签，然后按照从属关系即可直接取出电影名。<br>同理，我们借用此发方法来解析提取出电影的评分、介绍等需要的信息。</p>
<h2 id="附加问题"><a href="#附加问题" class="headerlink" title="附加问题"></a>附加问题</h2><p>我们刚才解析提取的仅仅是第一页的页面，那么还有第二、第三、第四页……呢？</p>
<p>其实，解决起来也很简单，我们可以使用for循环来对每一页进行上述的两个过程。</p>
<p>但，我们此时又有新的问题，我们不可能每抓取一次，就重新输入下一网页的链接地址，这样很麻烦，效率也不高。</p>
<p> 我们可以分析每一页的链接：</p>
<blockquote>
<p> 第一页：<a href="https://movie.douban.com/top250" target="_blank" rel="noopener">https://movie.douban.com/top250</a><br>第二页：<a href="https://movie.douban.com/top250?start=25" target="_blank" rel="noopener">https://movie.douban.com/top250?start=25</a><br>第三页：<a href="https://movie.douban.com/top250?start=50" target="_blank" rel="noopener">https://movie.douban.com/top250?start=50</a><br>第四页：<a href="https://movie.douban.com/top250?start=75" target="_blank" rel="noopener">https://movie.douban.com/top250?start=75</a><br>第五页：<a href="https://movie.douban.com/top250?start=100" target="_blank" rel="noopener">https://movie.douban.com/top250?start=100</a><br> … …<br> …. …</p>
</blockquote>
<p>我们可以发现这样的规律：<br>每一次的更新的 <code>url = https://movie.douban.com/top250 + &#39;/?start=&#39; + str(25*i)</code>其中<code>i</code>可以表示为页数-1</p>
<p>咦，这个时候，你可能会有疑问，我们怎么知道一共有多少页呢，不能一直for循环无穷吧。</p>
<p>那当然不可能的了，我们可以按第二步解析网页方式来获取页数</p>
<pre class="line-numbers language-python"><code class="language-python">depth <span class="token operator">=</span> soup<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">'next'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>previous_sibling<span class="token punctuation">.</span>previous_sibling<span class="token punctuation">.</span>text
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意，这个返回的<code>depth</code>是给字符串形式，需要<code>int()</code></p>
<p>这样结合刚才的过程，就可以迭代每一页了</p>
<h1 id="代码清单"><a href="#代码清单" class="headerlink" title="代码清单"></a>代码清单</h1><p>感兴趣的话，可以试一试哦</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> requests
<span class="token keyword">import</span> bs4

<span class="token comment" spellcheck="true">#抓取网页</span>
<span class="token keyword">def</span> <span class="token function">open_url</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>
    headers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"User-Agent"</span><span class="token punctuation">:</span><span class="token string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3314.0 Safari/537.36 SE 2.X MetaSr 1.0"</span><span class="token punctuation">}</span>
    res <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span>

    <span class="token keyword">return</span> res

<span class="token comment" spellcheck="true">#得到总页数</span>
<span class="token keyword">def</span> <span class="token function">find_depth</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">:</span>
    soup <span class="token operator">=</span> bs4<span class="token punctuation">.</span>BeautifulSoup<span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span>
    depth <span class="token operator">=</span> soup<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">'next'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>previous_sibling<span class="token punctuation">.</span>previous_sibling<span class="token punctuation">.</span>text

    <span class="token keyword">return</span> int<span class="token punctuation">(</span>depth<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">#解析网页，提取内容</span>
<span class="token keyword">def</span> <span class="token function">find_movies</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">:</span>
    soup <span class="token operator">=</span> bs4<span class="token punctuation">.</span>BeautifulSoup<span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span>

    names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    target <span class="token operator">=</span> soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">'hd'</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> target<span class="token punctuation">:</span>
        names<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">.</span>a<span class="token punctuation">.</span>span<span class="token punctuation">.</span>text<span class="token punctuation">)</span>

    ranks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    target <span class="token operator">=</span> soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">'rating_num'</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> target<span class="token punctuation">:</span>
        ranks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">.</span>text<span class="token punctuation">)</span>

    messages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    target <span class="token operator">=</span> soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">'bd'</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> target<span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            messages<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">.</span>p<span class="token punctuation">.</span>text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">.</span>p<span class="token punctuation">.</span>text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span><span class="token punctuation">:</span>
            <span class="token keyword">continue</span>

    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    length <span class="token operator">=</span> len<span class="token punctuation">(</span>names<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>
        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>names<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span>ranks<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> messages<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> result

<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    host <span class="token operator">=</span> <span class="token string">"https://movie.douban.com/top250"</span>
    res <span class="token operator">=</span> open_url<span class="token punctuation">(</span>host<span class="token punctuation">)</span>
    depth <span class="token operator">=</span> find_depth<span class="token punctuation">(</span>res<span class="token punctuation">)</span>

    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>depth<span class="token punctuation">)</span><span class="token punctuation">:</span>
        url <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">'/?start='</span> <span class="token operator">+</span> str<span class="token punctuation">(</span><span class="token number">25</span><span class="token operator">*</span>i<span class="token punctuation">)</span>
        res <span class="token operator">=</span> open_url<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
        result<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>find_movies<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"豆瓣TOP250电影.txt"</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
        <span class="token keyword">for</span> each <span class="token keyword">in</span> result<span class="token punctuation">:</span>
            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>each<span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">"__main__"</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="嘟嘟"><a href="#嘟嘟" class="headerlink" title="嘟嘟"></a>嘟嘟</h2><p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=3c2lknoq16w4k" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=3c2lknoq16w4k</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划解决矩阵连乘</title>
    <url>/2020/03/05/python-dong-tai-gui-hua-jie-jue-ju-zhen-lian-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态规划算法与分治法类似，其基本思想也就是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解，简单概括为自顶向下分解，自底向上求解。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是相互独立的，换句话说，就是前面解决过的子问题，在后面的子问题中又碰到了前面解决过的子问题，子问题之间是有联系的。如果用分治法，有些同样的子问题会被重复计算几次，这样就很浪费时间了。所以动态规划是为了解决分治法的弊端而提出的，动态规划的基本思想就是，用一个表来记录所有已经解决过的子问题的答案，不管该子问题在以后是否会被用到，只要它被计算过，就将其结果填入表中，以后碰到同样的子问题，就可以从表中直接调用该子问题的答案，而不需要再计算一次。具体的动态规划的算法多种多样，但他们都具有相同的填表式。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态规划的适用场合，一般适用于解最优化问题，例如矩阵连乘问题、最长公共子序列、背包问题等等。</p>
<h2 id="矩阵连乘问题描述"><a href="#矩阵连乘问题描述" class="headerlink" title="矩阵连乘问题描述"></a>矩阵连乘问题描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定n个矩阵：A1,A2,…,An，其中Ai与Ai+1是可乘的，i=1，2…，n-1。确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。输入数据为矩阵个数和每个矩阵规模，输出结果为计算矩阵连乘积的计算次序和最少数乘次数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若A是一个p × q的矩阵，B是一个q × r的矩阵，则其乘积C=AB是一个p × r的矩阵。数乘次数是p × q × r.</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>A(3 × 5)A(5 × 7)A(7 × 2)的连乘次数和括号划分有关系吗？</p>
<blockquote>
<p>(A(3 × 5)A(5 × 7))A(7 × 2)             相乘次数： (3 × 5 <em> 7)+(3 × 7 × 2) = 147<br>A(3 × 5)(A(5 × 7)A(7 × 2))             相乘次数： (5 × 7 </em> 2)+(3 × 5 × 2) = 100</p>
</blockquote>
<p>答案很明显是有关系的。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote>
<p>求 A1A2A3…An 定义   AiAi+1…Ak…Aj-1Aj   子列， 可看成是Ai…Ak，Ak…Aj<br>确定k的位置，然后按照递归的思想来逐步解决 求得结果后，使i=1，j=n原问题即可求解。</p>
</blockquote>
<p>建立递归关系（状态转移方程）</p>
<blockquote>
<p>设 Ai…Aj相乘 的最小数乘次数存储于m[i][j]中。<br>S[i][j]存储最佳断开位置。<br>A1：P0 × P1<br>A2：P1 × P2<br>A3：P2 × P3<br>…<br>Ai：Pi-1 × Pi<br>Ai+1：Pi × Pi+1<br> …<br> An：Pn-1 × Pn<br> P0 × P1 × P2 … × Pn——n+1个</p>
</blockquote>
<p>当i=j时，m[i][j] = 0;<br>当i&lt;j时，m[i][j] = m[i][k]+m[k+1][j]+Pi-1PkPj<br>k在i，j之间取值，取值范围为i&lt;=k&lt;j<br>有递推关系如下：<br><img src="https://img-blog.csdnimg.cn/20200305183034898.png" alt><br>动态规划的最优子结构性质是：</p>
<blockquote>
<p>问题的最优解包含了其子问题的最优解。<br>最优子结构性质是问题可用动态规划法求解的显著特征。<br>Ai…Ak，Ak+1…Aj的最优划分也包含在Ai…Aj的最优划分中</p>
</blockquote>
<p>在计算出最优值m[i][j]后，可递归地由s[i][j]构造出相应的最优解。</p>
<h2 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> random
<span class="token keyword">from</span> pandas <span class="token keyword">import</span> <span class="token operator">*</span>

input <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"输入矩阵数："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
matrix <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">:</span>                         <span class="token comment" spellcheck="true">#生成矩阵</span>
    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> random<span class="token punctuation">.</span>randrange<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
        matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> random<span class="token punctuation">.</span>randrange<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> random<span class="token punctuation">.</span>randrange<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
m <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> input <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">]</span>         <span class="token comment" spellcheck="true">#记录连乘次数</span>
s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> input <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">]</span>         <span class="token comment" spellcheck="true">#记录括号位置</span>
<span class="token keyword">def</span> <span class="token function">MatrixMultiplication</span><span class="token punctuation">(</span>inp<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>inp<span class="token punctuation">)</span><span class="token punctuation">:</span>
        m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> r <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> inp<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>inp<span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>
            j <span class="token operator">=</span> i <span class="token operator">+</span> r
            m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
            s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>
            <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>
                judge <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> matrix<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
                <span class="token keyword">if</span> judge <span class="token operator">&lt;</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> judge
                    s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token operator">+</span><span class="token number">1</span>
<span class="token keyword">def</span> <span class="token function">printmatrix</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> left <span class="token operator">==</span> right<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token operator">+</span>str<span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>
        printmatrix<span class="token punctuation">(</span>left<span class="token punctuation">,</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        printmatrix<span class="token punctuation">(</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>
MatrixMultiplication<span class="token punctuation">(</span>input<span class="token punctuation">)</span>
dm <span class="token operator">=</span> DataFrame<span class="token punctuation">(</span>m<span class="token punctuation">,</span> index<span class="token operator">=</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> input<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> columns<span class="token operator">=</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> input<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ds <span class="token operator">=</span> DataFrame<span class="token punctuation">(</span>s<span class="token punctuation">,</span> index<span class="token operator">=</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> input<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> columns<span class="token operator">=</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> input<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数乘次数：\n"</span><span class="token punctuation">,</span> dm<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"括号位置：\n"</span><span class="token punctuation">,</span> ds<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"最终结果："</span><span class="token punctuation">)</span>
printmatrix<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> input<span class="token number">-1</span><span class="token punctuation">)</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【小王子】摘录</title>
    <url>/2020/03/18/xiao-wang-zi-zheng-yin-wei-ni-wei-ni-de-mei-gui-hua-fei-liao-shi-jian-zhe-cai-shi-ni-de-mei-gui-bian-de-ru-ci-chong-yao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是法国名著《小王子》中一个有名的寓言故事，这个童话，实在太有智慧灵性了。人与人之间，不也是一样道理吗？我不得不承认，我被触动了。</p>
<h2 id="【小王子】"><a href="#【小王子】" class="headerlink" title="【小王子】"></a>【小王子】</h2><p> 有一天，小王子的星球上，不知从哪里来了一颗种子，后来忽然发了芽。小王子小心翼翼地监护着这株与众不同的嫩芽。小王子看到嫩芽长出一个巨大的花蕾，感到从中一定会产生奇迹。但是，这朵花儿却躲在她那绿茵茵的房间里，梳妆打扮没个完。一天清晨，正好当太阳升起的时候，她露面了。</p>
<p>   她，精心做了那么许多的准备，却伸着懒腰打着呵欠说：“哎呀！我刚刚睡醒。。。请原谅。。。瞧我的头发还是乱蓬蓬的。。。”</p>
<p>   小王子此时抑制不住自己那爱慕之情。</p>
<p>“你真美！”</p>
<p>“是么？你可知道，太阳是和我同时诞生的。。。”</p>
<p>   小王子看得出，这花儿很不谦虚，不过，她确实楚楚动人。</p>
<p>“我想，是该吃早点的时候了吧？”她随后又说，“请您记得我需要。。。”</p>
<p>   小王子感到十分惭愧，于是去提了一壶清水来给她浇灌。</p>
<p>   不久，她就以她的多疑的虚荣心来折磨小王子。例如，有一天，她谈起她身上长着的四根刺时，她对小王子说：“老虎么，让它们带着它们的利抓来吧！”</p>
<p>“我的星球上根本没有老虎，”小王子反驳说，“而且老虎是不吃草的。”</p>
<p>   花儿娇嗔地说：“我可不是草。”</p>
<p>“请原谅！”</p>
<p>“我不怕什么老虎，可是我受不了穿堂风，您没有屏风吗？”</p>
<p>   小王子思忖着：“受不了穿堂风。。。这对一株植物来说，太不幸了。这朵花儿有点难弄…”</p>
<p>   这时，她故意咳得更响，好使他良心受责备。</p>
<p>   尽管小王子真心诚意爱这朵花儿，这样一来，他开始对她产生怀疑了。小王子对一些无关紧要的话，看得过分认真，结果使自己很苦恼。</p>
<p>   小王子选择了离开，去旅行。</p>
<p>   临行那天早上，当小王子最后一次浇花，准备为她盖上玻璃罩子时，他觉得自己想哭出来。</p>
<p>“再见了！”他对花儿说。</p>
<p>   花儿咳嗽起来，但并不是由于感冒。她终于开口说：“我真傻，我请求你的原谅。祝你幸福。”她居然没有一句责备他的话，这实在使他感到意外。他站在那里手足无措，玻璃罩举在半空。他不懂得这份脉脉的柔情。</p>
<p>   “的确，我爱你。”花儿对他说，“但是你一点儿都没体会到，这实在是我的错。再说也没有用了。不过，你过去也和我一样的傻。希望你今后幸福。。。把罩子放到一边去吧，我用不着它了。”</p>
<p>“要是风。。。”</p>
<p>“我的感冒并没有那么厉害。。。晚间的凉风对我有好处。我是花儿呀。”</p>
<p>“要是虫子野兽。。。”</p>
<p>“我要是想结识蝴蝶，我就应当忍受得了两三只小毛虫在身上爬。据说，这很美妙。如果没有蝴蝶和毛虫，还有谁来看我呢？你么，你又远在天边。至于大动物，我并不怕，我有爪子。”</p>
<p>   她天真地伸出她那四根刺，随后又说：“别这样磨磨蹭蹭啦，这挺叫人烦心！你既然决定走，那就快走吧！” </p>
<p> 她是怕小王子看见她哭。这是一朵有傲气的花。。。 </p>
<p>   有一天，小王子对我倾诉：“我当时什么也不懂！我应该根据她的行动，而不是根据她的话判断她。她对我散发芳香，她使我的生活充满阳光。我真不该离开她。我本应看得出她耍的那些小花招后面隐藏着的一片柔情。花儿是多么里外不一致！我当时年纪太小，不懂得爱她。”</p>
<p>   小王子走着走着，这时候，一只狐狸出现了。</p>
<p>“你好！”狐狸说。</p>
<p>“你好！”小王子彬彬有礼地回答。但回头一看，什么也没有看见。</p>
<p>“我就在这儿。”那声音说，“在苹果树下。”</p>
<p>“你是谁？”小王子说，“你真漂亮。”</p>
<p>“我是狐狸。”狐狸说。</p>
<p>“来跟我玩玩吧。”小王子建议说，“我很不开心。。。”</p>
<p>“我不能跟你玩，”狐狸说，“我还没经过驯养。”</p>
<p>“啊，对不起！”小王子说。但是，想了一想后，他又说：“什么叫做驯养？”</p>
<p>   狐狸说：“意思就是：建立一种关系。”</p>
<p>“建立关系？”</p>
<p>   “一点不错，”狐狸说，“在我看来，你只不过是一个小男孩，跟成千上万的男孩毫无两样。我不需要你，你也不需要我。对你来说我只不过是一只狐狸，跟成千上万的狐狸毫无两样。但是，你如果驯养了我，那么我们俩就彼此相互需要。对我来说，你是世界上独一无二的；我在你看来，也是世界上独一无二的。。。”</p>
<p>   狐狸叹口气说：“世上没有十全十美的事，我的生活很单调枯燥，但是，如果你驯养了我，我的生活就会充满阳光。我会听得出一种与众不同的脚步声。别的脚步声会使我往洞里钻，你的脚步声却像音乐一般，把我从洞里召唤出来。还有，你看！那边的麦田，你看见了吗？我不吃面包，麦子对我来说，一点也没用。麦田不能引起我什么联想，这真使人扫兴！但是，你有金色的头发。一旦你驯养了我，那就会十分美妙！麦子，黄澄澄，会使我联想到你，而且我甚至会喜欢风吹麦浪的沙沙声。。。”</p>
<p>   狐狸没说下去，盯着小王子看了好久。</p>
<p>“请你。。。驯养我吧！”他说。</p>
<p>   “我是很愿意的，”小王子回答道，“可是我的时间不多。我还要认识一些新朋友，了解许许多多的事。”</p>
<p>   “人们只能了解自己所驯养的东西，”狐狸说，“人们不会有时间去了解任何东西。他们想要什么东西，都往商店去买现成的。可是，世界上没有可以购买朋友的商店，所以人也就得不到朋友。你要朋友，就请驯养我吧！”</p>
<p>“要驯养，该怎样做呢？”小王子说。</p>
<p>   “必须非常耐心。”狐狸回答道，“首先，你离我远一点，像这样，坐在草地上。我用眼梢瞅着你，你一句话也别说。话语往往是误会的根源。不过，每天你坐得更靠近我一些。。。”</p>
<p>   第二天，小王子又来了。</p>
<p>   “最好还是在同一时间来，”狐狸说，“比如说，你在下午四点钟来，一到三点钟我就开始感到幸福了。时间越接近，我就越感到幸福。到了四点钟，我就会坐立不安，焦虑重重；我就会发现幸福的代价。可是，你如果想什么时间来就什么时间来，我就不知道什么时候准备好我的心。。。应当有一定的常规。”</p>
<p>“常规是什么？”小王子问道。</p>
<p>   “这也是被人差不多忘得一干二净的事，”狐狸说，“这就是使某一天与其他日子不同，使某一时刻与其他时刻不同。比如说，猎人也有一种常规。他们每星期四都和乡村里的姑娘跳舞。星期四就成为我开心的日子！我甚至可以一直逛到葡萄园。要是猎人什么时候都去跳舞，这一天和其他日子没什么不同，那我就终年没放假的日子了。”</p>
<p>   于是小王子驯养了狐狸。当小王子快要离开时，狐狸说：“哎！。。。我想哭。”</p>
<p>   “这是你自己的错，我从未想过要使你难受，但是，你却要我驯养你。。。”小王子说。</p>
<p>“是这样！”狐狸说。</p>
<p>“可是你现在又要哭！”小王子说。</p>
<p>“当然啦。”狐狸说。</p>
<p>“这样对你有什么好处。”</p>
<p>“对我有好处。”狐狸说，“有了麦子的颜色。”</p>
<p>   小王子走了。路上他碰见满园的玫瑰花儿。</p>
<p>   满园的玫瑰花儿向小王子用力点着头微笑，小王子说：“你们很美，但你们是空虚的。没有人会为你们去死。当然，我的那朵玫瑰，一个普通的过路人会认为她们和你们是一样的。可是，她单独一朵比你们全体更可贵，因为我给她浇过水，因为我为她盖过罩子，因为我给她用屏风挡风，因为我倾听过她的怨艾，她的夸口，有时甚至倾听她的沉默。因为她是我的玫瑰花。”</p>
<p>   小王子又回到狐狸身旁：“再见了。。。狐狸”</p>
<p>“再见了。”狐狸说，“本质的东西，眼睛是看不到的，只有用心灵看。”</p>
<p>“本质的东西，眼睛是看不到的，只有用心灵看。”小王子重复这句话，以免忘记。</p>
<p>“正是因为我对我的玫瑰，花费了时间，才使花儿变得那么重要。”小王子重复这句话，以免忘记。</p>
<p>“这个真理，已经被人忘记了，”狐狸说，“但是你千万不要忘记。对你驯养的东西，你要永远负责。你必须对你的花儿负责。。。”</p>
<p>“我要对我的花儿负责。”小王子又重复跟着说，为了牢牢记住。</p>
<h4 id="摘自《小王子》"><a href="#摘自《小王子》" class="headerlink" title="摘自《小王子》"></a>摘自《小王子》</h4>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络（CNN）</title>
    <url>/2019/07/30/juan-ji-shen-jing-wang-luo-cnn/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CNN，即卷积神经网络，主要用于图像识别，分类。这篇卷积神经网络是前面介绍的多层神经网络的进一步深入，它将深度学习的思想引入到了神经网络当中，通过卷积运算来由浅入深的提取图像的不同层次的特征，而利用神经网络的训练过程让整个网络自动调节卷积核的参数，从而无监督的产生了最适合的分类特征。</p>
<h1 id="一、卷积神经网络的网络结构"><a href="#一、卷积神经网络的网络结构" class="headerlink" title="一、卷积神经网络的网络结构"></a>一、卷积神经网络的网络结构</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;卷积神经网络主要由这几类层构成：输入层、卷积层，ReLU层、池化（Pooling）层和全连接层（全连接层和常规神经网络中的一样）。通过将这些层叠加起来，就可以构建一个完整的卷积神经网络。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际应用中往往将卷积层与ReLU层共同称之为卷积层，所以卷积层经过卷积操作也是要经过激活函数的。具体说来，卷积层和全连接层（CONV/FC）对输入执行变换操作的时候，不仅会用到激活函数，还会用到很多参数，即神经元的权值w和偏差b；而ReLU层和池化层则是进行一个固定不变的函数操作。卷积层和全连接层中的参数会随着梯度下降被训练，这样卷积神经网络计算出的分类评分就能和训练集中的每个图像的标签吻合了。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81NzA4NjI0LTExYjJmODM1ZGMyM2NiZGUucG5n" alt></p>
<h1 id="二、卷积层"><a href="#二、卷积层" class="headerlink" title="二、卷积层"></a>二、卷积层</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;卷积层是构建卷积神经网络的核心层，它产生了网络中大部分的计算量。注意是计算量而不是参数量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先简单给大家介绍一下什么叫做卷积，那么白话解释一下啥叫卷积，很形象，就是“卷”，你假象一下，你把毛巾卷起来，成为一个圆柱体的卷，就是这个意思，抽象的说，就是将原来的对象变小一些，但又能保证原来图像中的信息尽量多的保留下来，可以看看下面这个卷积过程图。看看这个图，大概理解卷积是一个什么样子的过程就可以了，用映射两个字我认为是比较恰当的。</p>
<h2 id="1-卷积过程"><a href="#1-卷积过程" class="headerlink" title="1.卷积过程"></a>1.卷积过程</h2><p>二维卷积：即滤波器的每个格子与滤波器选中数据的格子相乘。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfZ2lmL0JQNkhRTjZST3B4bTJEbWh4QnQ3ZXJsZUVTZEx1WFNZN1lPcDZsUmZkWTdvUUlnS3pGSGt2cTQxQXhnWnNPZVh5dElaS2VYSWozVUJ0aWIwb3d5NHl2Zy8w" alt></p>
<p>三维卷积：三维数据的话，滤波器的也是三维。同时对每个维度进行卷积，最后将每个维度的卷积结果相加，输出二维。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yNTA5NTU3LTUwY2M2M2EyOTU1N2I2MzAucG5n" alt></p>
<h2 id="2-过滤器"><a href="#2-过滤器" class="headerlink" title="2.过滤器"></a>2.过滤器</h2><p><strong>过滤器的作用是：寻找图片的特征</strong>。<br>这就涉及到CNN要做的工作了。每一个过滤器中的数值，都是算法自己学习来的，不需要我们费心去设置。</p>
<p>需要我们做的有：</p>
<p>① <strong>设置过滤器的大小</strong>（用字母“F”表示）</p>
<p>一般情况下，我们的过滤器大小是3×3，即F=3。</p>
<p>当然，你还可以设置成5×5，都是可以的。</p>
<p>只不过，需要注意的是：过滤器的尺寸越大，得到的图像细节就越少，最终得到的特征图的尺寸也更小。</p>
<p>② <strong>设置过滤器滑动的步幅数</strong>（用字母“S”表示）</p>
<p>一般情况下，过滤器滑动的步幅是1，即每次过滤器向右或向下滑动1个像素单位。</p>
<p>当然，你也可以将步幅设置为2或更多，但是通常情况下，我们会使用S=1或S=2。</p>
<p>③ <strong>设置过滤器的个数</strong>（用字母“K”表示）</p>
<p>以下，我们分别给大家展示了4种过滤器。所以你可以理解为K=4，如下图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2FpcG9ydGFsLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAxNy8xMi80JUU3JUE3JThEJUU4JUJGJTg3JUU2JUJCJUE0JUU1JTk5JUE4LnBuZw" alt></p>
<p>当然，你可以设置任意个数。</p>
<p>再次强调：不要在意过滤器里面的数值，那是算法自己学习来的，不需要我们操心，我们只要把过滤器的个数设置好，就可以了。</p>
<p>所以，一张图片，在经过4种过滤器的提取后，会得到4种不同的特征图片：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2FpcG9ydGFsLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAxNy8xMi8yMiVFNSU5QiU5QiVFNyVBNyU4RCVFOCVCRiU4NyVFNiVCQiVBNCVFNSU5OSVBOC0lRTYlOTUlODglRTYlOUUlOUMuanBn" alt></p>
<p>从上面的例子我们能够看到，“卷积”输出的结果，是包含“宽、高、深”3个维度的：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2FpcG9ydGFsLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAxNy8xMi8yNCVFNSVBRSVCRCVFOSVBQiU5OCVFNiVCNyVCMS5wbmc" alt></p>
<p>实际上，在CNN中，所有图片都是包含有“宽、高、深”。</p>
<p>像输入的图片——萌狗，它也是包含3个维度，只不过，它的深度是1，所以在我们的图片中没有明显地体现出来：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2FpcG9ydGFsLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAxNy8xMi8yNiVFOSVCQiU5MSVFNyU5OSVCRCVFNSU5QiVCRS0lRTYlQjclQjElRTUlQkElQTYuanBn" alt></p>
<p>所以，我们要记住，经过“卷积”层的处理后，图片含有深度，这个“深度”，等于过滤器的个数。</p>
<p>例如，上面我们采用了4种过滤器，那么，输出的结果，深度就为4。</p>
<p>④ <strong>设置是否补零</strong>（用字母“P”表示）</p>
<p>何为“补零”？</p>
<p>当我们采用了3×3大小的过滤器，直接在原始图片滑过。</p>
<p>从结果中可以看到，最终得到的“特征图片”比“原始图片”小了一圈：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2FpcG9ydGFsLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAxNy8xMi8yNyVFOCVBMSVBNSVFOSU5QiVCNi0lRTUlOUIlQkUlRTUlODMlOEYlRTUlOEYlOTglRTUlQjAlOEYucG5n" alt></p>
<p>为什么会出现这种情况？</p>
<p>原因很简单：过滤器将原始图片中，每3*3=9个像素点，提取为1个像素点</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2FpcG9ydGFsLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAxNy8xMi8yOCVFNyVCQyVBOSVFNSVCMCU4RiVFNSU4RSU5RiVFNSU5QiVBMC5wbmc" alt></p>
<p>所以，当过滤器遍历整个图片后，得到的特征图片会比原始图片更小。</p>
<p>当然，你也可以得到一个和原始图片大小一样的特征图，这就需要采用“在原始图片外围补零”的方法：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2FpcG9ydGFsLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAxNy8xMi8yOSVFOCVBMSVBNSVFOSU5QiVCNi5qcGc" alt><br>下面，我们来看看“补零”后的效果：</p>
<p><img src="https://img-blog.csdnimg.cn/201908151547000.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<p>如何确定“补零”的圈数，才能保证图片大小一致？<br>假设你的过滤器大小为F，滑动步幅S=1，想要实现这一目标，补零的个数应为：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2FpcG9ydGFsLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAxNy8xMi8zMSVFOCVBMSVBNSVFOSU5QiVCNiVFNSU4NSVBQyVFNSVCQyU4Ri5wbmc" alt></p>
<p>举个例子：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上图中，因为我们使用的是3*3大小的过滤器，而且每次滑动时，都是向右或向下移动1格。</p>
<p>所以，为了使特征图片与原始图片保持一致，需要补零P=(3-1)/2=1，即在原始图片外围，补1圈零。</p>
<p>如果你使用的过滤器大小为5*5，那么补零P=(5-1)/2=2，即在原始图片外围，补2圈零。</p>
<p>当然，是否需要“补零”，由你自己来决定，<strong>“补零”并不是硬性规定。</strong></p>
<h2 id="3-卷积层（Conv-Layer）的输出张量（图像）的大小计算"><a href="#3-卷积层（Conv-Layer）的输出张量（图像）的大小计算" class="headerlink" title="3.卷积层（Conv Layer）的输出张量（图像）的大小计算"></a>3.卷积层（Conv Layer）的输出张量（图像）的大小计算</h2><p>定义如下：</p>
<p>O=输出图像的尺寸。</p>
<p>I=输入图像的尺寸。</p>
<p>K=卷积层的核尺寸</p>
<p>N=核数量</p>
<p>S=移动步长</p>
<p>P =填充数</p>
<p>输出图像尺寸的计算公式如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTA5MzYzNy8yMDE4MDkvMTA5MzYzNy0yMDE4MDkyNTIxMjEyNjQxOC0yMjU3NzY3LnBuZw" alt><br>输出图像的通道数等于核数量N。</p>
<p>示例：AlexNet中输入图像的尺寸为227<em>227</em>3.第一个卷积层有96个尺寸为11<em>11</em>3的核。步长为4，填充为0.<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTA5MzYzNy8yMDE4MDkvMTA5MzYzNy0yMDE4MDkyNTIxMjE0ODI4OC0xODkxNjg3MjQ5LnBuZw" alt><br>输出的图像为55<em>55</em>96（每个核对应1个通道）</p>
<h2 id="4-卷积层作用"><a href="#4-卷积层作用" class="headerlink" title="4. 卷积层作用"></a>4. 卷积层作用</h2><ol>
<li><p><strong>滤波器的作用或者说是卷积的作用</strong>。卷积层的参数是有一些可学习的滤波器集合构成的。每个滤波器在空间上（宽度和高度）都比较小，但是深度和输入数据一致（这一点很重要，后面会具体介绍）。直观地来说，网络会让滤波器学习到当它看到某些类型的视觉特征时就激活，具体的视觉特征可能是某些方位上的边界，或者在第一层上某些颜色的斑点，甚至可以是网络更高层上的蜂巢状或者车轮状图案。</p>
</li>
<li><p><strong>可以被看做是神经元的一个输出</strong>。神经元只观察输入数据中的一小部分，并且和空间上左右两边的所有神经元共享参数（因为这些数字都是使用同一个滤波器得到的结果）。</p>
</li>
<li><p><strong>降低参数的数量</strong>。这个由于卷积具有“权值共享”这样的特性，可以降低参数数量，达到降低计算开销，防止由于参数过多而造成过拟合。</p>
</li>
</ol>
<h1 id="三、激活函数"><a href="#三、激活函数" class="headerlink" title="三、激活函数"></a>三、激活函数</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MDg2NjU0LTFkMTM1ZGU0YzU3YzE4YWU" alt></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图所示，一个filter或者神经元的内部计算过程，我们可以看到通过卷积并加上bias后（其实在感知机那个时代到这一步就可以了，模型就具备了线性分类的能力，但是大千世界我们的分类问题很少是线性函数可以拟合的，所以我们就需要拟合非线性函数），filter还做了一次函数映射运算，这里的函数 f 就是我们的非线性激活函数，它的作用是：使模型不再是线性组合，具有可以逼近任意函数的能力。下图就是我们经常使用激活函数 ReLU，还有sigmoid函数或者tanh函数这些，读者可以自行搜索。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MDg2NjU0LWMxZTY3NzYwNWQ2YWZiZDM" alt></p>
<p>如果是负数，出来的结果就是0</p>
<p>如果是正数或零，出来的结果仍是自己本身</p>
<p>举个例子：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设经过“过滤器”提取后，得到的“特征图片”其像素值如左下图，那么，经过ReLU处理后，得到的“新的”特征图片会呈现右下图形态：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvMzglRTUlOUIlQkUlRTclODklODdSZWx1LnBuZw" alt></p>
<p>回到我们之前的例子中，在“卷积”的后面，再加上一步“ReLU计算”，即为：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvMzklRTYlOUUlQjYlRTYlOUUlODQxLnBuZw" alt></p>
<h1 id="四、池化层"><a href="#四、池化层" class="headerlink" title="四、池化层"></a>四、池化层</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时图像太大，即使我们参数不太多，但图像的像素实在太多，导致卷积操作后，我们得到的结果仍然过大。我们需要减少训练参数的数量，它被要求在随后的卷积层之间周期性地引进池化层。池化的一个目的是减少图像的空间大小。池化在每一个纵深维度上独自完成，因此图像的纵深保持不变。</p>
<h2 id="1-池化过程"><a href="#1-池化过程" class="headerlink" title="1.池化过程"></a>1.池化过程</h2><p><strong>所谓“池化”，就是在保留图片主要信息的前提下，将图片的尺寸缩小。</strong>  </p>
<p>池化的类型有很多种，诸如“最大池化”、“平均池化”、“求和池化”等等，它们的运算原理基本一致。</p>
<p>因为“最大池化”更为常用，所以我们重点介绍“最大池化”的运算过程。</p>
<p>假设经过ReLU处理后，我们得到的特征图片，如下图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvNDAlRTYlOUMlODAlRTUlQTQlQTclRTYlQjElQTAlRTUlOEMlOTYtMDEuanBn" alt></p>
<p>在对特征图片进行“池化”处理时，与“卷积”类似，需要我们设置2个超参数：</p>
<p>过滤器大小（F）和 滑动的步幅数（S）<br>这里，假设我们设置F=2，S=2，那么，“最大池化”为：</p>
<p>在每2*2（即4个）像素区域内，保留像素值最大的那一个，其余3个像素值抛弃。<br>如下图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvNDElRTYlOUMlODAlRTUlQTQlQTclRTYlQjElQTAlRTUlOEMlOTYlRTglQkYlOTAlRTclQUUlOTcucG5n" alt></p>
<p>这样，经过“池化”处理，就将一个4<em>4大小的图片，缩小为2</em>2大小的图片了。</p>
<p>当然，在“池化”过程中，你也可以将超参数设置为F=3、S=2，只不过“F=2、S=2”更为常用。</p>
<p>回到我们之前的例子中，在“ReLU计算”的后面，再加上一步“最大池化”，即为：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvNDIlRTYlOUUlQjYlRTYlOUUlODQyLnBuZw" alt></p>
<h2 id="2-池化层（MaxPool-Layer）的输出张量（图像）的大小计算"><a href="#2-池化层（MaxPool-Layer）的输出张量（图像）的大小计算" class="headerlink" title="2.池化层（MaxPool Layer）的输出张量（图像）的大小计算"></a>2.池化层（MaxPool Layer）的输出张量（图像）的大小计算</h2><p>定义如下：</p>
<p>O=输出图像的尺寸。<br>I=输入图像的尺寸。<br>S=移动步长<br>PS=池化层尺寸</p>
<p>输出图像尺寸的计算公式如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTA5MzYzNy8yMDE4MDkvMTA5MzYzNy0yMDE4MDkyNTIxMjIzNTAxMS0yNTk2OTY1NDIucG5n" alt><br>不同于卷积层，池化层的输出通道数不改变。</p>
<p>示例：每1层卷积层后的池化层的池化层尺寸为3<em>3，步长为2。根据前面卷积层的输出为55</em>55<em>96。池化层的输出图像尺寸如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTA5MzYzNy8yMDE4MDkvMTA5MzYzNy0yMDE4MDkyNTIxMjI0MzU3NS04Njc0MDE5NTYucG5n" alt><br>输出尺寸为27</em>27*96。</p>
<h2 id="3-池化的作用和特点："><a href="#3-池化的作用和特点：" class="headerlink" title="3.池化的作用和特点："></a>3.池化的作用和特点：</h2><ol>
<li>降维，减少网络的参数，达到防止过拟合的效果</li>
<li>可以实现平移、旋转的不变性</li>
<li>只改变图像尺寸，不改变图像深度</li>
<li>没有需要训练的参数</li>
</ol>
<h1 id="五、卷积和池化的叠加"><a href="#五、卷积和池化的叠加" class="headerlink" title="五、卷积和池化的叠加"></a>五、卷积和池化的叠加</h1><p>有的时候，我们会进行多次卷积和池化，所以，更一般的形式：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvNDMtJUU2JTlFJTg0JUU2JTlFJUI2LSVFNiU4RCVBMi5wbmc" alt></p>
<p>举个例子：</p>
<p>★ 你可以构建2层“卷积 + ReLU”，如下：</p>
<p>输入图片 → 卷积 → ReLU → 卷积 → ReLU → 池化</p>
<p>★ 也可以构建2层“卷积 + ReLU + 池化”：</p>
<p>输入图片 → 卷积 → ReLU → 池化 → 卷积 → ReLU → 池化</p>
<p>当然，你还可以构建更多网络层，这里就不一一列举了。</p>
<h1 id="六、全连接层"><a href="#六、全连接层" class="headerlink" title="六、全连接层"></a>六、全连接层</h1><p>经过上面一系列的处理，此时得到的图片，已经可以被视为一串串简单的数字（即像素值）。</p>
<p>将这一个个的像素值，塞到我们早已接触过的表达式中：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvNDclRTglQTElQTglRTglQkUlQkUlRTUlQkMlOEYucG5n" alt></p>
<p><strong>x是谁？</strong></p>
<p>在计算机“眼中”的世界，图像是这样的：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvN2RvZy0lRTklQkIlOTElRTclOTklQkQtJUU1JTgzJThGJUU3JUI0JUEwLTEuanBn" alt></p>
<p>那一个格子、一个格子中的数字，就是x。</p>
<p><strong>y是谁？</strong></p>
<p>我们给每张图片打上的标签：这张图是“猫”、那张图是“狗”…… 统统这些标签，就是y。</p>
<p><strong>θ又是什么？</strong></p>
<p>当你给计算机很多组、很多组（x,y）时，它会自己去学习寻找x与y之间的关系，这个“关系”，就是θ。</p>
<p>当你拥有了θ，下一次，即使拿到一张没有打过标签的图片，你也可以通过已知的θ和x，知道y的取值，从而“知道图片里画的是什么？”。</p>
<p><strong>具体过程：</strong></p>
<p>首先，需要把卷积后得到的图片，其中的像素值“展开”。</p>
<p>为了方便大家理解，假设我们卷积后，得到了2张2*2的图片，如果把它们的像素值“展开”，得到的效果为：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvNDhGQy0wNy5qcGc" alt></p>
<p>这样，我们就拿到了x。展开后所得到的 </p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvNDgtJUU4JUExJUE1LmpwZw" alt><br>就是x。</p>
<p>在训练的最初，我们拥有每张图片的标签，即“我们已经拥有了y值”。</p>
<p>所以，在模型的最后，我们需要让计算机努力找到x-y之间的关系。</p>
<p>而寻找的办法，就需要依靠“全连接神经网络”：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvNDlGQy5wbmc" alt><br>所谓“全连接”，是指下一层的每一个神经元（即图中的“□”），与上一层的神经元全部相连，这里为了表达得更清晰，已经省去了中间的连接符。实际上，更多的时候，你会看到下面这样的图片：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvNTBGQy0xMC5qcGc" alt><br>过，本文的重点不在于讲解“全连接神经网络”，本文的核心在于卷积神经网络（CNN）。</p>
<p>这里，你只需要记住2点：</p>
<p>① “全连接神经网络”可以帮助我们学习到参数θ。有了它，下一次再给计算机“看”图片时，计算机便会自动识别出图中的景象。</p>
<p>② 模型得到的最终结果，表示“图片为某种类别的概率”。注意：这里的概率之和，永远为1。</p>
<p>例如：<img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvNTFGQyVFNyVCQiU5MyVFNiU5RSU5Qy5wbmc" alt><br>即计算机“判断”，最初输入的图片为“狗”。</p>
<p>我们将CNN的所有流程，整合起来，即：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5haXBvcnRhbC5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTIvNTIlRTYlOTUlQjQlRTUlOTAlODglRTUlOUIlQkUlRUYlQkMlODglRTklODclODclRTclOTQlQTglRUYlQkMlODkuanBn" alt></p>
<h1 id="六、纵观"><a href="#六、纵观" class="headerlink" title="六、纵观"></a>六、纵观</h1><p>其实卷积神经网络(CNN)与人工神经网络(ANN)的大概思路是一样的，包括两个阶段：</p>
<p>第一阶段，向前传播阶段：</p>
<p>a）从样本集中取一个样本(X,Yp)，将X输入网络；</p>
<p>b）计算相应的实际输出Op。</p>
<p>在此阶段，信息从输入层经过逐级的变换，传送到输出层。这个过程也是网络在完成训练后正常运行时执行的过程。在此过程中，网络执行的是计算（实际上就是输入与每层的权值矩阵相点乘，得到最后的输出结果）：</p>
<p>Op=Fn（…（F2（F1（XpW（1））W（2））…）W（n））</p>
<p>第二阶段，向后传播阶段</p>
<p>a）算实际输出Op与相应的理想输出Yp的差；</p>
<p>b）按极小化误差的方法反向传播调整权矩阵。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>卷积神经网络（CNN）</tag>
      </tags>
  </entry>
  <entry>
    <title>人工神经网络（ANN）</title>
    <url>/2019/07/26/ren-gong-shen-jing-wang-luo-ann/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初学人工智能不久，今天碰上了人工神经网（ANN），开始学的时候很懵，一大堆理论、公式、推导…..作为一名小白，还是很痛苦的，不过经过摸索，大概了 解了什么是ANN，公式的推导以及一些其他问题，下面我就总结下自己的理解，一方面作为自己的笔记，日后方便巩固；另一方面，也可以分享给其他有意者。</p>
<h1 id="一、什么是神经网络"><a href="#一、什么是神经网络" class="headerlink" title="一、什么是神经网络"></a>一、什么是神经网络</h1><h2 id="1-单层神经网络"><a href="#1-单层神经网络" class="headerlink" title="1.单层神经网络"></a>1.单层神经网络</h2><p>首先以单层神经元为例解释人工神经元是如何工作的<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMubGVpcGhvbmUuY29tL3VwbG9hZHMvbmV3L2FydGljbGUvNzQwXzc0MC8yMDE2MDgvNTdiZDUyZjMwMjYzZC5wbmc" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x1,x2,…, xN：神经元的输入。这些可以从输入层实际观测或者是一个隐藏层的中间值（隐藏层即介于输入与输出之间的所有节点组成的一层。后面讲到多层神经网络是会再跟大家解释的）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X0：偏置单元。这是常值添加到激活函数的输入（类似数学里y＝ax+b中使直线不过原点的常数b）。即截距项，通常有＋1值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w0,w1,w2,…,wN：对应每个输入的权重。甚至偏置单元也是有权重的。</p>
<p>a:神经元的输出。计算如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMubGVpcGhvbmUuY29tL3VwbG9hZHMvbmV3L2FydGljbGUvNzQwXzc0MC8yMDE2MDgvNTdiZDUyZjQ2NzM2Zi5wbmc" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;式子里的f是已知的激活函数，f使神经网络（单层乃至多层）非常灵活并且具有能估计复杂的非线性关系的能力。在简单情况下可以是一个高斯函数、逻辑函数、双曲线函数或者甚至上是一个线性函数。利用神经网络可让其实现三个基本功能：与、或、非（AND, OR, NOT）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里引入一个例子：and功能实现如下<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMubGVpcGhvbmUuY29tL3VwbG9hZHMvbmV3L2FydGljbGUvNzQwXzc0MC8yMDE2MDgvNTdiZDUyZjc3YjA2Yy5wbmc" alt><br>神经元输出：a = f( -1.5 + x1 + x2 )</p>
<p>这样大家就很容易理解其工作原理，其实就是对输入值赋予不同权重，经过激活函数输出的过程。</p>
<h2 id="2-多层神经网络"><a href="#2-多层神经网络" class="headerlink" title="2.多层神经网络"></a>2.多层神经网络</h2><h3 id="2-1-网络结构"><a href="#2-1-网络结构" class="headerlink" title="2.1 网络结构"></a>2.1 网络结构</h3><p>清楚了单层神经网络，多层神经网络也好理解了，就相当于多个单层的叠加成多层的过程。<br><img src="https://img-blog.csdnimg.cn/20190811204232448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br><strong>神经网络分为三种类型的层</strong>：</p>
<p>输入层：神经网络最左边的一层，通过这些神经元输入需要训练观察的样本，即初始输入数据的一层。</p>
<p>隐藏层：介于输入与输出之间的所有节点组成的一层。帮助神经网络学习数据间的复杂关系，即对数据进行处理的层。</p>
<p>输出层：由前两层得到神经网络最后一层，即最后结果输出的一层。</p>
<h3 id="2-2-传递函数-激活函数"><a href="#2-2-传递函数-激活函数" class="headerlink" title="2.2 传递函数/激活函数"></a>2.2 传递函数/激活函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面每一层输入经过线性变换wx+b后还用到了sigmoid函数，在神经网络的结构中被称为传递函数或者激活函数。除了sigmoid，还有tanh、relu等别的激活函数。激活函数使线性的结果非线性化。</p>
<h3 id="2-3-为什么需要传递函数"><a href="#2-3-为什么需要传递函数" class="headerlink" title="2.3 为什么需要传递函数"></a>2.3 为什么需要传递函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单理解上，如果不加激活函数，无论多少层隐层，最终的结果还是原始输入的线性变化，这样一层隐层就可以达到结果，就没有多层感知器的意义了。所以每个隐层都会配一个激活函数，提供非线性变化。</p>
<h1 id="二、BP算法"><a href="#二、BP算法" class="headerlink" title="二、BP算法"></a>二、BP算法</h1><h2 id="1-BP算法基本思想"><a href="#1-BP算法基本思想" class="headerlink" title="1.BP算法基本思想"></a>1.BP算法基本思想</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BP算法全称叫作误差反向传播(error Back Propagation，或者也叫作误差逆传播)算法。其算法基本思想为：在上述的前馈网络中，输入信号经输入层输入，通过隐层计算由输出层输出，输出值与标记值比较，若有误差，将误差反向由输出层向输入层传播，在这个过程中，利用梯度下降算法对神经元权值进行调整。</p>
<h2 id="2-BP算法的推导"><a href="#2-BP算法的推导" class="headerlink" title="2.BP算法的推导"></a>2.BP算法的推导</h2><h3 id="2-1-数学基础理论"><a href="#2-1-数学基础理论" class="headerlink" title="2.1 数学基础理论"></a>2.1 数学基础理论</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BP算法中核心的数学工具就是微积分的<strong>链式求导法则</strong>。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjQxMzk3LWMwN2Q1ODFjOTJkYWViZWMucG5n" alt></p>
<h3 id="2-2推导过程"><a href="#2-2推导过程" class="headerlink" title="2.2推导过程"></a>2.2推导过程</h3><p><img src="https://img-blog.csdnimg.cn/20190811205148228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<ol>
<li><strong>正向传播求损失，反向传播回传误差</strong></li>
<li>根据误差信号修正每层的权重 </li>
<li>f是激活函数；f(netj)是隐层的输出； f(netk）是输出层的输出O; d是target</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合BP网络结构，误差由输出展开至输入的过程如下：<br><img src="https://img-blog.csdnimg.cn/20190811205328707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>有了误差E，通过求偏导就可以求得最优的权重。（不要忘记学习率） </p>
<p><img src="https://img-blog.csdnimg.cn/2019081120540142.png" alt></p>
<h2 id="3-举例说明"><a href="#3-举例说明" class="headerlink" title="3. 举例说明"></a>3. 举例说明</h2><p><img src="https://img-blog.csdnimg.cn/20190811205641720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>图中元素：<br>两个输入；<br>隐层: b1, w1, w2, w3, w4 (都有初始值）<br>输出层：b2, w5, w6, w7, w8（赋了初始值）</p>
<h3 id="3-1-前向传播"><a href="#3-1-前向传播" class="headerlink" title="3.1 前向传播"></a>3.1 前向传播</h3><p><img src="https://img-blog.csdnimg.cn/20190811205743162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>则误差：<br><img src="https://img-blog.csdnimg.cn/20190811205806851.png" alt></p>
<h3 id="3-2-反向传播"><a href="#3-2-反向传播" class="headerlink" title="3.2 反向传播"></a>3.2 反向传播</h3><p><img src="https://img-blog.csdnimg.cn/20190811205859442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>参数更新：<br><img src="https://img-blog.csdnimg.cn/20190811205921617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>求误差对w1的偏导 ：<br><img src="https://img-blog.csdnimg.cn/20190811205940706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>注意，w1对两个输出的误差都有影响<br>通过以上过程可以更新所有权重，就可以再次迭代更新了，直到满足条件。</p>
<h1 id="三、python代码实现"><a href="#三、python代码实现" class="headerlink" title="三、python代码实现"></a>三、python代码实现</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上述例子，用python可写出如下代码，并附有详解：</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
import math
a=np.array([0.05,0.1])           #a1,a2的输入值
weight1=np.array([[0.15,0.25],[0.2,0.3]])   #a1对b1,b2的权重，a2对b1，b2的权重
weight2=np.array([[0.4,0.5],[0.45,0.55]])     #b1对c1,c2的权重，b2对c1，c2的权重
target=np.array([0.01,0.99])
d1=0.35   #输入层的偏置（1）的权重
d2=0.6    #隐藏层的偏置（1）的权重
β=0.5    #学习效率

#一：前向传播

#计算输入层到隐藏层的输入值，得矩阵netb1,netb2
netb=np.dot(a,weight1)+d1

#计算隐藏层的输出值,得到矩阵outb1,outb2
m=[]
for i in range(len(netb)):
    outb=1.0 / (1.0 + math.exp(-netb[i]))
    m.append(outb)
m=np.array(m)

#计算隐藏层到输出层的输入值，得矩阵netc1,netc2
netc=np.dot(m,weight2)+d2

#计算隐藏层的输出值,得到矩阵outc1,outc2
n=[]
for i in range(len(netc)):
    outc=1.0 / (1.0 + math.exp(-netc[i]))
    n.append(outc)
n=np.array(n)

#二：反向传播
count=0 #计数
e=0     #误差  
E=[]    #统计误差
#梯度下降
while True:
  count+=1

  #总误差对w1-w4的偏导
  pd1=(-(target[0]-n[0])*n[0]*(1-n[0])*weight2[0][0]-(target[1]-n[1])*n[1]*(1-n[1])*weight2[0][1])*m[0]*(1-m[0])*a[0]
  pd2=(-(target[0]-n[0])*n[0]*(1-n[0])*weight2[0][0]-(target[1]-n[1])*n[1]*(1-n[1])*weight2[0][1])*m[0]*(1-m[0])*a[1]
  pd3=(-(target[0]-n[0])*n[0]*(1-n[0])*weight2[1][0]-(target[1]-n[1])*n[1]*(1-n[1])*weight2[0][1])*m[0]*(1-m[0])*a[0]                          
  pd4=(-(target[0]-n[0])*n[0]*(1-n[0])*weight2[1][1]-(target[1]-n[1])*n[1]*(1-n[1])*weight2[0][1])*m[0]*(1-m[0])*a[1]
  weight1[0][0]=weight1[0][0]-β*pd1
  weight1[1][0]=weight1[1][0]-β*pd2
  weight1[0][1]=weight1[0][1]-β*pd3
  weight1[1][1]=weight1[1][1]-β*pd4

  #总误差对w5-w8的偏导
  pd5=-(target[0]-n[0])*n[0]*(1-n[0])*m[0]
  pd6=-(target[0]-n[0])*n[0]*(1-n[0])*m[1]
  pd7=-(target[1]-n[1])*n[1]*(1-n[1])*m[0]
  pd8=-(target[1]-n[1])*n[1]*(1-n[1])*m[1]
  weight2[0][0]=weight2[0][0]-β*pd5
  weight2[1][0]=weight2[1][0]-β*pd6
  weight2[0][1]=weight2[0][1]-β*pd7
  weight2[1][1]=weight2[1][1]-β*pd8

  netb=np.dot(a,weight1)+d1
  m=[]
  for i in range(len(netb)):
    outb=1.0 / (1.0 + math.exp(-netb[i]))
    m.append(outb)
  m=np.array(m)
  netc=np.dot(m,weight2)+d2
  n=[]
  for i in range(len(netc)):
    outc=1.0 / (1.0 + math.exp(-netc[i]))
    n.append(outc)
  n=np.array(n)

  #计算总误差
  for j in range(len(n)):
    e += (target[j]-n[j])**2/2
  E.append(e)
  #判断
  if e&lt;0.0000001:
    break
  else:
      e=0
print(count)
print(e)
print(n)
plt.plot(range(len(E)),E,label=&#39;error&#39;)
plt.legend() 
plt.xlabel(&#39;time&#39;)
plt.ylabel(&#39;error&#39;)
plt.show()
</code></pre><h1 id="四、BP神经网络的优缺点"><a href="#四、BP神经网络的优缺点" class="headerlink" title="四、BP神经网络的优缺点"></a>四、BP神经网络的优缺点</h1><p><strong>BP神经网络的优点：</strong></p>
<ol>
<li>非线性映射能力</li>
<li>泛化能力  </li>
<li>容错能力，允许输入样本中带有较大误差甚至个别错误。反应正确规律的知识来自全体样本，个别样本中的误差不能左右对权矩阵的调整</li>
</ol>
<p><strong>BP神经网络的缺陷：</strong></p>
<ol>
<li>需要的参数过多，而且参数的选择没有有效的方法。确定一个BP神经网络需要知道：网络的层数、每一层神经元的个数和权值。权值可以通过学习得到，如果，隐层神经元数量太多会引起过学习，如果隐层神经元个数太少会引起欠学习。此外学习率的选择也是需要考虑。目前来说，对于参数的确定缺少一个简单有效的方法，所以导致算法很不稳定；</li>
<li>属于监督学习，对于样本有较大依赖性，网络学习的逼近和推广能力与样本有很大关系，如果样本集合代表性差，样本矛盾多，存在冗余样本，网络就很难达到预期的性能；</li>
<li>由于权值是随机给定的，所以BP神经网络具有不可重现性；</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>BP算法</tag>
        <tag>人工神经网络（ANN）</tag>
      </tags>
  </entry>
  <entry>
    <title>基于协同过滤（CF）算法的推荐系统</title>
    <url>/2019/07/28/ji-yu-xie-tong-guo-lu-cf-suan-fa-de-tui-jian-xi-tong/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 随着计算机领域技术的高速发展，电子商务时代的普及，个性化的推荐系统深入生活应用的各个方面。个性化推荐算法是推荐系统中最核心的技术，在很大程度上决定了电子商务推荐系统性能的优劣。而协同过滤推荐是个性化推荐系统应用最为广泛的技术，协同过滤推荐主要分为基于用户的协同过滤推荐、基于项目的协同过滤推荐和基于模型的协同过滤推荐。</p>
<h1 id="一、协同过滤算法描述"><a href="#一、协同过滤算法描述" class="headerlink" title="一、协同过滤算法描述"></a>一、协同过滤算法描述</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大数据时代产生了海量的数据，里面蕴含了丰富的价值。但是，大数据体量之大、种类之繁以及产生速率之快，海量的数据并不都是有价值的，用户从海量的数据中提取有用的、针对性的信息需要花费很大的时间成本。比如，当你面对如此多的电影列表，你想找到一部最符合自己兴趣的电影，因为电影数量之多，你不可能把所有的电影简介都看一遍。那么怎么解决这个问题呢？电影平台搜集你过去看过的全部电影，分析了解你对什么类型电影感兴趣，然后针对性的把你感兴趣的电影主动的罗列给你，你不用花费太多的精力便可快速找到满足自己需求的电影。推荐算法便是为解决这类实际需求而诞生了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 推荐系统应用数据分析技术，找出用户最可能喜欢的东西推荐给用户，现在很多电子商务网站都有这个应用。目前用的比较多、比较成熟的推荐算法是协同过滤（Collaborative Filtering，简称CF）推荐算法，CF的基本思想是根据用户之前的喜好以及其他兴趣相近的用户的选择来给用户推荐物品。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMjAzLzE2LzBfMTMzMTkwOTY5MFhVcEkuZ2lm" alt><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，在CF中，用m×n的矩阵表示用户对物品的喜好情况，一般用打分表示用户对物品的喜好程度，分数越高表示越喜欢这个物品，0表示没有买过该物品。图中行表示一个用户，列表示一个物品，Uij表示用户i对物品j的打分情况。CF分为两个过程，一个为预测过程，另一个为推荐过程。预测过程是预测用户对没有购买过的物品的可能打分值，推荐是根据预测阶段的结果推荐用户最可能喜欢的一个或Top-N个物品。</p>
<h1 id="二、协同过滤的实现"><a href="#二、协同过滤的实现" class="headerlink" title="二、协同过滤的实现"></a>二、协同过滤的实现</h1><p>要实现协同过滤的推荐算法，要进行以下三个步骤：</p>
<ul>
<li>收集数据</li>
<li>找到相似用户或物品</li>
<li>进行推荐</li>
</ul>
<h2 id="1、收集数据"><a href="#1、收集数据" class="headerlink" title="1、收集数据"></a>1、收集数据</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的数据指的都是用户的历史行为数据，比如用户的购买历史，关注，收藏行为，或者发表了某些评论，给某个物品打了多少分等等，这些都可以用来作为数据供推荐算法使用，服务于推荐算法。需要特别指出的在于，不同的数据准确性不同，在使用时需要考虑到噪音所带来的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要从用户的行为和偏好中发现规律，并基于此给予推荐，如何收集用户的偏好信息成为系统推荐效果最基础的决定因素。用户有很多方式向系统提供自己的偏好信息，而且不同的应用也可能大不相同，如下图：<br><img src="https://img-blog.csdnimg.cn/20190813212211411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="2、找到相似用户或物品"><a href="#2、找到相似用户或物品" class="headerlink" title="2、找到相似用户或物品"></a>2、找到相似用户或物品</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一步其实就是计算用户间以及物品间的相似度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于相似度的计算，现有的几种基本方法都是基于向量（Vector）的，其实也就是计算两个向量的距离，距离越近相似度越大。在推荐的场景中，在用户 - 物品偏好的二维矩阵中，我们可以将一个用户对所有物品的偏好作为一个向量来计算用户之间的相似度，或者将所有用户对某个物品的偏好作为一个向量来计算物品之间的相似度。下面我们详细介绍几种常用的相似度计算方法：<br><img src="https://img-blog.csdnimg.cn/20190813212300649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<p>下一步是作出预测。你可以运用下面的公式做一个预测：<br><img src="https://img-blog.csdn.net/20180408164703642" alt></p>
<h2 id="3、进行推荐"><a href="#3、进行推荐" class="headerlink" title="3、进行推荐"></a>3、进行推荐</h2><h3 id="3-1、基于用户的协同过滤推荐-User-based-Collaborative-Filtering-Recommendation"><a href="#3-1、基于用户的协同过滤推荐-User-based-Collaborative-Filtering-Recommendation" class="headerlink" title="3.1、基于用户的协同过滤推荐(User-based Collaborative Filtering Recommendation)"></a>3.1、基于用户的协同过滤推荐(User-based Collaborative Filtering Recommendation)</h3><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于用户的协同过滤推荐算法先使用统计技术寻找与目标用户有相同喜好的邻居，然后根据目标用户的邻居的喜好产生向目标用户的推荐。基本原理就是利用用户访问行为的相似性来互相推荐用户可能感兴趣的资源，如图所示：</p>
<p><img src="https://img-blog.csdn.net/20161020214409502" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图示意出基于用户的协同过滤推荐机制的基本原理，假设用户 A 喜欢物品 A、物品 C，用户 B 喜欢物品 B，用户 C 喜欢物品 A 、物品 C 和物品 D；从这些用户的历史喜好信息中，我们可以发现用户 A 和用户 C 的口味和偏好是比较类似的，同时用户 C 还喜欢物品 D，那么我们可以推断用户 A 可能也喜欢物品 D，因此可以将物品 D 推荐给用户 A。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于用户的协同过滤推荐机制和基于人口统计学的推荐机制都是计算用户的相似度，并基于“邻居”用户群计算推荐，但它们所不同的是如何计算用户的相似度，基于人口统计学的机制只考虑用户本身的特征，而基于用户的协同过滤机制可是在用户的历史偏好的数据上计算用户的相似度，它的基本假设是，喜欢类似物品的用户可能有相同或者相似的口味和偏好。</p>
<h3 id="3-2、基于项目的协同过滤推荐-Item-based-Collaborative-Filtering-Recommendation"><a href="#3-2、基于项目的协同过滤推荐-Item-based-Collaborative-Filtering-Recommendation" class="headerlink" title="3.2、基于项目的协同过滤推荐(Item-based Collaborative Filtering Recommendation)"></a>3.2、基于项目的协同过滤推荐(Item-based Collaborative Filtering Recommendation)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据所有用户对物品或者信息的评价，发现物品和物品之间的相似度，然后根据用户的历史偏好信息将类似的物品推荐给该用户，如图所示：<br><img src="https://img-blog.csdn.net/20160821160630777" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图表明基于项目的协同过滤推荐的基本原理，用户A喜欢物品A和物品C，用户B喜欢物品A、物品B和物品C，用户C喜欢物品A，从这些用户的历史喜好中可以认为物品A与物品C比较类似，喜欢物品A的都喜欢物品C，基于这个判断用户C可能也喜欢物品C，所以推荐系统将物品C推荐给用户C。<br>       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于项目的协同过滤推荐和基于内容的协同过滤推荐都是基于物品相似度预测推荐，只是相似度度量的方法不一样，前者是从用户历史的偏好推断，而后者是基于物品本身的属性特征信息。</p>
<h3 id="3-3、UserCF和ItemCF的区别"><a href="#3-3、UserCF和ItemCF的区别" class="headerlink" title="3.3、UserCF和ItemCF的区别"></a>3.3、UserCF和ItemCF的区别</h3><p><img src="https://img-blog.csdn.net/20170107105218959" alt></p>
<h1 id="三、算法实例"><a href="#三、算法实例" class="headerlink" title="三、算法实例"></a>三、算法实例</h1><p>以ItemCF为例子具体介绍下整个算法流程。<br><strong>算法流程：</strong></p>
<ol>
<li>构建用户–&gt;物品的倒排；</li>
<li>构建物品与物品的同现矩阵；</li>
<li>计算物品之间的相似度，即计算相似矩阵；</li>
<li>根据用户的历史记录，给用户推荐物品；</li>
</ol>
<h2 id="算法流程1"><a href="#算法流程1" class="headerlink" title="算法流程1"></a>算法流程1</h2><p>构建用户–&gt;物品的倒排<br>如下表，行表示用户，列表示物品，1表示用户喜欢该物品<br><img src="https://img-blog.csdnimg.cn/20190814085502109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<pre><code>例如python构建的数据格式如下
{
&#39;A&#39;: {&#39;a&#39;: &#39;1&#39;, &#39;b&#39;: &#39;1&#39;, &#39;d&#39;: &#39;1&#39;}, 
&#39;B&#39;: {&#39;c&#39;: &#39;1&#39;, &#39;b&#39;: &#39;1&#39;, &#39;e&#39;: &#39;1&#39;}, 
&#39;C&#39;: {&#39;c&#39;: &#39;1&#39;, &#39;d&#39;: &#39;1&#39;}, 
&#39;D&#39;: {&#39;c&#39;: &#39;1&#39;, &#39;b&#39;: &#39;1&#39;, &#39;d&#39;: &#39;1&#39;},
&#39;E&#39;: {&#39;a&#39;: &#39;1&#39;, &#39;d&#39;: &#39;1&#39;}
}
</code></pre><h2 id="算法流程2"><a href="#算法流程2" class="headerlink" title="算法流程2"></a>算法流程2</h2><p>构建物品与物品的同现矩阵</p>
<p>共现矩阵C表示同时喜欢两个物品的用户数，是根据用户物品倒排表计算出来的。如根据上面的用户物品倒排表可以计算出如下的共现矩阵C：<br><img src="https://img-blog.csdnimg.cn/20190814085654185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="算法流程3"><a href="#算法流程3" class="headerlink" title="算法流程3"></a>算法流程3</h2><p>计算物品之间的相似度，即计算相似矩阵</p>
<p>其中两个物品之间的相似度如何计算？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设|N(i)|表示喜欢物品i的用户数，|N(i)⋂N(j)|表示同时喜欢物品i，j的用户数，则物品i与物品j的相似度为： </p>
<p><img src="https://img-blog.csdnimg.cn/20190814090106195.png" alt></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)式有一个问题，当物品j是一个很热门的商品时，人人都喜欢，那么wijwij就会很接近于1，即(1)式会让很多物品都和热门商品有一个很大的相似度，所以可以改进一下公式：</p>
<p><img src="https://img-blog.csdnimg.cn/2019081409030146.png" alt></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法流程2中的共现矩阵C其实就是式(2)的分子，矩阵N（用于计算分母）表示喜欢某物品的用户数（是总的用户数），则(2)式中的分母便很容易求解出来了。</p>
<p>矩阵N如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190814090318574.png" alt></p>
<p>利用式（2）便能计算物品之间的余弦相似矩阵如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2019081409034757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="算法流程4"><a href="#算法流程4" class="headerlink" title="算法流程4"></a>算法流程4</h2><p>根据用户的历史记录，给用户推荐物品；</p>
<p>最终推荐的是什么物品，是由预测兴趣度决定的。</p>
<p><strong>物品j预测兴趣度=用户喜欢的物品i的兴趣度×物品i和物品j的相似度</strong></p>
<p>例如：A用户喜欢a，b，d ，兴趣度分别为1,1,1</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;推荐c的预测兴趣度=1X0.67+1X0.58=1.25<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;推荐e的预测兴趣度=1X0.58=0.58</p>
<h1 id="四、python实现案例"><a href="#四、python实现案例" class="headerlink" title="四、python实现案例"></a>四、python实现案例</h1><pre><code>from math import sqrt
import operator

#1.构建用户--&gt;物品的倒排
def loadData(files):
    data ={}
    for line in files:
        user,score,item=line.split(&quot;,&quot;)  #按&quot;,&quot;将每组数据单独分开,并将每组的数据赋予对应变量
        data.setdefault(user,{})
        data[user][item]=score
    print (&quot;----1.用户：物品的倒排----&quot;)
    print (data)
    return data

#2.计算
# 2.1 构造物品--&gt;物品的共现矩阵
# 2.2 计算物品与物品的相似矩阵
def similarity(data):
    # 2.1 构造物品：物品的共现矩阵
    N={};#喜欢物品i的总人数
    C={};#喜欢物品i也喜欢物品j的人数
    for user,item in data.items():
        for i,score in item.items():
            N.setdefault(i,0)
            N[i]+=1
            C.setdefault(i,{})
            for j,scores in item.items():
                if j not in i:
                    C[i].setdefault(j,0)
                    C[i][j]+=1

    print (&quot;---2.构造的共现矩阵---&quot;)
    print (&#39;N:&#39;,N)
    print (&#39;C:&#39;,C)

    #2.2 计算物品与物品的相似矩阵
    W={};
    for i,item in C.items():
        W.setdefault(i,{})
        for j,item2 in item.items():
            W[i].setdefault(j,0)
            W[i][j]=C[i][j]/sqrt(N[i]*N[j])
    print (&quot;---3.构造的相似矩阵---&quot;)
    print (W)
    return W

#3.根据用户的历史记录，给用户推荐物品
def recommandList(data,W,user,k=3,N=10):
    rank={}
    for i,score in data[user].items():#获得用户user历史记录，如A用户的历史记录为{&#39;a&#39;: &#39;1&#39;, &#39;b&#39;: &#39;1&#39;, &#39;d&#39;: &#39;1&#39;}
        for j,w in sorted(W[i].items(),key=operator.itemgetter(1),reverse=True)[0:k]:#获得与物品i相似的k个物品
            if j not in data[user].keys():#该相似的物品不在用户user的记录里
                rank.setdefault(j,0)
                rank[j]+=float(score) * w

    print (&quot;---4.推荐----&quot;)
    print (sorted(rank.items(),key=operator.itemgetter(1),reverse=True)[0:N])
    return sorted(rank.items(),key=operator.itemgetter(1),reverse=True)[0:N]

if __name__==&#39;__main__&#39;:
    #用户，兴趣度，物品
    uid_score_bid = [&#39;A,1,a&#39;, &#39;A,1,b&#39;, &#39;A,1,d&#39;, &#39;B,1,b&#39;, &#39;B,1,c&#39;, &#39;B,1,e&#39;, &#39;C,1,c&#39;, &#39;C,1,d&#39;, &#39;D,1,b&#39;, &#39;D,1,c&#39;, &#39;D,1,d&#39;,
                     &#39;E,1,a&#39;, &#39;E,1,d&#39;]
    data=loadData(uid_score_bid)#获得数据
    W=similarity(data)#计算物品相似矩阵
    recommandList(data,W,&#39;A&#39;,3,10)#推荐
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了方便理解python的实现过程，这里只用了少数数据集并是手输上去的，具体情况运用可再加段代码用于读取并处理数据文件。</p>
<h1 id="五、算法的优缺点"><a href="#五、算法的优缺点" class="headerlink" title="五、算法的优缺点"></a>五、算法的优缺点</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个算法实现起来也比较简单，但是在实际应用中有时候也会有问题的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如一些非常流行的商品可能很多人都喜欢，这种商品推荐给你就没什么意义了，所以计算的时候需要对这种商品加一个权重或者把这种商品完全去掉也行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再有，对于一些通用的东西，比如买书的时候的工具书，如现代汉语词典，新华字典神马的，通用性太强了，推荐也没什么必要了。</p>
<p><strong>UserCF和ItemCF优缺点的对比</strong><br><img src="https://img-blog.csdnimg.cn/20190814083729968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>协同过滤（CF）</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>多种相似度计算方法</title>
    <url>/2019/07/24/duo-chong-xiang-si-du-ji-suan-de-python-shi-xian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在机器学习中有很多地方要计算相似度，比如聚类分析和协同过滤。计算相似度的有许多方法，其中有欧几里德距离(欧式距离)、曼哈顿距离、Jaccard系数和皮尔逊相关度等等。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们这里把一些常用的相似度计算方法，用python进行实现以下。大家都是初学者，我认为把公式先写下来，然后再写代码去实现比较好。 </p>
<h2 id="欧几里德距离-欧式距离"><a href="#欧几里德距离-欧式距离" class="headerlink" title="欧几里德距离(欧式距离)"></a>欧几里德距离(欧式距离)</h2><p>几个数据集之间的相似度一般是基于每对对象间的距离计算。最常用的当然是欧几里德距离，其公式为：<br><img src="https://img-blog.csdnimg.cn/20190724204320390.png" alt></p>
<pre><code>#-*-coding:utf-8 -*-

#计算欧几里德距离：
def euclidean(p,q):
#如果两数据集数目不同，计算两者之间都对应有的数
same = 0
for i in p:
    if i in q:
        same +=1

#计算欧几里德距离,并将其标准化
e = sum([(p[i] - q[i])**2 for i in range(same)])
return 1/(1+e**.5)
</code></pre><p>我们用数据集可以去算一下： </p>
<pre><code>p = [1,3,2,3,4,3]
q = [1,3,4,3,2,3,4,3]
print euclidean(p,q)
</code></pre><p>得出结果是：0.261203874964</p>
<h2 id="皮尔逊相关度"><a href="#皮尔逊相关度" class="headerlink" title="皮尔逊相关度"></a>皮尔逊相关度</h2><p>几个数据集中出现异常值的时候，欧几里德距离就不如皮尔逊相关度‘稳定’，它会在出现偏差时倾向于给出更好的结果。其公式为：<br><img src="https://img-blog.csdnimg.cn/20190724204538985.png" alt></p>
<pre><code>-*-coding:utf-8 -*-

#计算皮尔逊相关度：
def pearson(p,q):
#只计算两者共同有的
    same = 0
    for i in p:
        if i in q:
            same +=1

    n = same
    #分别求p，q的和
    sumx = sum([p[i] for i in range(n)])
    sumy = sum([q[i] for i in range(n)])
    #分别求出p，q的平方和
    sumxsq = sum([p[i]**2 for i in range(n)])
    sumysq = sum([q[i]**2 for i in range(n)])
    #求出p，q的乘积和
    sumxy = sum([p[i]*q[i] for i in range(n)])
    # print sumxy
    #求出pearson相关系数
    up = sumxy - sumx*sumy/n
    down = ((sumxsq - pow(sumxsq,2)/n)*(sumysq - pow(sumysq,2)/n))**.5
    #若down为零则不能计算，return 0
    if down == 0 :return 0
    r = up/down
    return r
</code></pre><p>用同样的数据集去计算：</p>
<pre><code>p = [1,3,2,3,4,3]
q = [1,3,4,3,2,3,4,3]
print pearson(p,q)
</code></pre><p>得出结果是：0.00595238095238</p>
<h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><p>曼哈顿距离是另一种相似度计算方法，不是经常需要，但是我们仍然学会如何用python去实现，其公式为：<br><img src="https://img-blog.csdnimg.cn/20190724204709370.png" alt></p>
<pre><code>#-*-coding:utf-8 -*-

#计算曼哈顿距离：
def manhattan(p,q):
#只计算两者共同有的
    same = 0
    for i in p:
        if i in q:
        same += 1
#计算曼哈顿距离
    n = same
    vals = range(n)
    distance = sum(abs(p[i] - q[i]) for i in vals)
    return distance
</code></pre><p>用以上的数据集去计算：</p>
<pre><code>p = [1,3,2,3,4,3]
q = [1,3,4,3,2,3,4,3]
print manhattan(p,q)
</code></pre><p>得出结果为4</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里只讲述了三种相似度的计算方法，事实上还有很多种，由于我也是刚学，其他的方法还不是很了解，以后碰到了再补上。一般情况下，这三种方法是最常用的，足够我们使用了。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
        <tag>相似度</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期培训第一次测试题总结</title>
    <url>/2019/07/22/shu-qi-pei-xun-di-yi-ci-ce-shi-ti-zong-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里是一些暑期培训第一次测试题的部分解释，经过这次测试的摧残，总结备录一下，方便日后回顾复习。</p>
<h2 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过几天的学习，7月22日下午，进行了第一次检测。开始以为会让我们推导一些公式什么的，结果当拿到测试题的时候，一首凉凉送给自己……开始的选择题和填空题还能接受，看到简答题，这都是什么，有种似曾相识的感觉，但就是写不出来。为时四十分钟的考试结束后，不到半个小时成绩就出来了，虽然成绩不那么好，但排名还行，然后学长给我们进行了讲解答疑，发现自己学的有点粗糙，没有注意那些细节性问题和概念，学以致用这方面也是有点差的。</p>
<h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test 1"></a>Test 1</h2><h3 id="为什么一般需要划分出额外的校验集-validation-set-用于超参数调整，而不选择直接使用测试集-test-set"><a href="#为什么一般需要划分出额外的校验集-validation-set-用于超参数调整，而不选择直接使用测试集-test-set" class="headerlink" title="为什么一般需要划分出额外的校验集(validation set)用于超参数调整，而不选择直接使用测试集(test set)?"></a>为什么一般需要划分出额外的校验集(validation set)用于超参数调整，而不选择直接使用测试集(test set)?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;校验集是用于调整超参数的，从而更好的优化训练模型。测试集是用于在完成神经网络训练过程后,为了客观评价模型在其未见过(未曾影响普通参数和超参数选择)的数据上的性能,而且测试集<strong>不能提出对参数或者超参数的修改意见,只能作为评价网络性能的一个指标</strong>。</p>
<p>（备注：不清楚这三个数据集概念及其作用的，可看下我以前写的关于这些的一篇文章。传送门：）</p>
<h2 id="Test-2"><a href="#Test-2" class="headerlink" title="Test 2"></a>Test 2</h2><h3 id="批量梯度下降-Batch-Gradient-Descent-和随机梯度下降-Stochastic-Gradient-Descent-在应对鞍点时有何不同表现？"><a href="#批量梯度下降-Batch-Gradient-Descent-和随机梯度下降-Stochastic-Gradient-Descent-在应对鞍点时有何不同表现？" class="headerlink" title="批量梯度下降(Batch Gradient Descent)和随机梯度下降(Stochastic Gradient Descent)在应对鞍点时有何不同表现？"></a>批量梯度下降(Batch Gradient Descent)和随机梯度下降(Stochastic Gradient Descent)在应对鞍点时有何不同表现？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要先知道什么是BGD和SGD，从两者的运算方法上，我们就可以得知不同之处。</p>
<p>（1）批量梯度下降法（Batch Gradient Descent） ：在更新参数时都使用所有的样本来进行更新。</p>
<ul>
<li>优点：<strong>全局最优解</strong>，能保证每一次更新权值，都能降低损失函数；易于并行实现。</li>
<li>缺点：当样本数目很多时，训练过程会很慢。</li>
</ul>
<p>（2）随机梯度下降法（Stochastic Gradient Descent）：在更新参数时都使用一个样本来进行更新。每一次跟新参数都用一个样本，更新很多次。如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已经将参数迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次，这种方式计算复杂度太高。</p>
<ul>
<li>优点：训练速度快；</li>
<li>缺点：准确度下降，<strong>并不是全局最优</strong>；不易于并行实现。从迭代的次数上来看，随机梯度下降法迭代的次数较多，在解空间的搜索过程看起来很盲目。噪音很多，使得它并不是每次迭代都向着整体最优化方向。</li>
</ul>
<h2 id="Test-3"><a href="#Test-3" class="headerlink" title="Test 3"></a>Test 3</h2><h3 id="当一个模型训练完后若在训练集上的loss非常高，请问如何在不对代码进行全面排查的前提下，以最快速度定位是模型本身的拟合能力不足还是代码的实现存在某种错误？"><a href="#当一个模型训练完后若在训练集上的loss非常高，请问如何在不对代码进行全面排查的前提下，以最快速度定位是模型本身的拟合能力不足还是代码的实现存在某种错误？" class="headerlink" title="当一个模型训练完后若在训练集上的loss非常高，请问如何在不对代码进行全面排查的前提下，以最快速度定位是模型本身的拟合能力不足还是代码的实现存在某种错误？"></a>当一个模型训练完后若在训练集上的loss非常高，请问如何在不对代码进行全面排查的前提下，以最快速度定位是模型本身的拟合能力不足还是代码的实现存在某种错误？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;废话不多说，直接上图：<br><img src="https://img-blog.csdnimg.cn/20190722174826448.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="Test-4"><a href="#Test-4" class="headerlink" title="Test 4"></a>Test 4</h2><h3 id="假设我们在训练一个使用Sigmoid激活函数的全连接神经网络。在对其权重进行初始化时，为什么一般会倾向于让初始值的绝对值偏小？如果需要这样，为何不直接使用0进行初始化？"><a href="#假设我们在训练一个使用Sigmoid激活函数的全连接神经网络。在对其权重进行初始化时，为什么一般会倾向于让初始值的绝对值偏小？如果需要这样，为何不直接使用0进行初始化？" class="headerlink" title="假设我们在训练一个使用Sigmoid激活函数的全连接神经网络。在对其权重进行初始化时，为什么一般会倾向于让初始值的绝对值偏小？如果需要这样，为何不直接使用0进行初始化？"></a>假设我们在训练一个使用Sigmoid激活函数的全连接神经网络。在对其权重进行初始化时，为什么一般会倾向于让初始值的绝对值偏小？如果需要这样，为何不直接使用0进行初始化？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于逻辑回归，把权重初始化为0当然也是可以的，但是对于一个神经网络，如果你把权重或者参数都初始化为0，那么梯度下降将不会起作用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果权值全初始化为0，则<strong>无法更新权值</strong>。这是由于前向传播中，所有节点输出值均相同，由于此处使用了sigmod激活函数，所以此处所有神经节点输出都为1/2，而在反向传播每个节点输出值对损失函数的偏导时，涉及到对权值相乘后的求和，该项永远为0，故所乘的结果也必然为0，这样在计算权值对算是函数的偏导时，其偏导必然为0，所有权值偏导都为0，那么就不要指望使用梯度下降法能更新权值了，自然神经网络的训练也就无法进行下去了。</p>
<h2 id="Test-5"><a href="#Test-5" class="headerlink" title="Test 5"></a>Test 5</h2><h3 id="在CNN中梯度不稳定指的是什么？在神经网络训练过程中，为什么会出现梯度消失的问题？如何解决？"><a href="#在CNN中梯度不稳定指的是什么？在神经网络训练过程中，为什么会出现梯度消失的问题？如何解决？" class="headerlink" title="在CNN中梯度不稳定指的是什么？在神经网络训练过程中，为什么会出现梯度消失的问题？如何解决？"></a>在CNN中梯度不稳定指的是什么？在神经网络训练过程中，为什么会出现梯度消失的问题？如何解决？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;神经网络中的梯度不稳定指的是<strong>梯度消失</strong>和<strong>梯度爆炸</strong>问题。<br>（备注：对于这两种问题的具体解释和为什么会出现这种问题，以及解决方法，这里不具体讨论了，我会在以后的文章中具体解释到的。）</p>
<h2 id="Test-6"><a href="#Test-6" class="headerlink" title="Test 6"></a>Test 6</h2><h3 id="为什么在神经网络中使用交叉熵而不是均方差作为误差函数？"><a href="#为什么在神经网络中使用交叉熵而不是均方差作为误差函数？" class="headerlink" title="为什么在神经网络中使用交叉熵而不是均方差作为误差函数？"></a>为什么在神经网络中使用交叉熵而不是均方差作为误差函数？</h3><pre><code>1. 神经网络中如果预测值与实际值的误差越大，那么在反向传播训练的过程中，各种参数调整的幅度就要更大，从而使训练更快收敛，如果预测值与实际值的误差小，各种参数调整的幅度就要小，从而减少震荡。

2. 使用平方误差损失函数，误差增大参数的梯度会增大，但是当误差很大时，参数的梯度就会又减小了。

3. 使用交叉熵损失是函数，误差越大参数的梯度也越大，能够快速收敛。
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（备注：对于结论的推导过程会总结在另一篇文章里。）</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>测试题</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素贝叶斯算法</title>
    <url>/2019/08/05/po-su-bei-xie-si-suan-fa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;朴素贝叶斯算法是流行的十大算法之一，该算法是有监督的学习算法，解决的是分类问题，如客户是否流失、是否值得投资、信用等级评定等多分类问题。<strong>该算法的优点在于简单易懂、学习效率高、在某些领域的分类问题中能够与决策树、神经网络相媲美。</strong>但由于该算法以自变量之间的独立（条件特征独立）性和连续变量的正态性假设为前提，就会导致算法精度在某种程度上受影响。</p>
<h1 id="一、问题的提出"><a href="#一、问题的提出" class="headerlink" title="一、问题的提出"></a>一、问题的提出</h1><p>先举一个具体的例子：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“一所学校里面有 60% 的男生，40% 的女生。男生总是穿长裤，女生则一半穿长裤一半穿裙子。有了这些信息之后我们可以容易地计算“随机选取一个学生，他（她）穿长裤的概率和穿裙子的概率是多大”，这个就是前面说的“正向概率”的计算。然而，假设你走在校园中，迎面走来一个穿长裤的学生（很不幸的是你高度近似，你只看得见他（她）穿的是否长裤，而无法确定他（她）的性别），你能够推断出他（她）是男生的概率是多大吗？”</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们来算一算：假设学校里面人的总数是 U 个。60% 的男生都穿长裤，于是我们得到了 U <em> P(Boy) </em> P(Pants|Boy) 个穿长裤的（男生）（其中 P(Boy) 是男生的概率 = 60%，这里可以简单的理解为男生的比例；P(Pants|Boy) 是条件概率，即在 Boy 这个条件下穿长裤的概率是多大，这里是 100% ，因为所有男生都穿长裤）。40% 的女生里面又有一半（50%）是穿长裤的，于是我们又得到了 U <em> P(Girl) </em> P(Pants|Girl) 个穿长裤的（女生）。加起来一共是 U <em> P(Boy) </em> P(Pants|Boy) + U <em> P(Girl) </em> P(Pants|Girl) 个穿长裤的，其中有 U <em> P(Girl) </em> P(Pants|Girl) 个女生。两者一比就是你要求的答案。<br>下面我们把这个答案形式化一下：我们要求的是 P(Girl|Pants) （穿长裤的人里面有多少女生），我们计算的结果是 U <em> P(Girl) </em> P(Pants|Girl) / [U <em> P(Boy) </em> P(Pants|Boy) + U <em> P(Girl) </em> P(Pants|Girl)] 。容易发现这里校园内人的总数是无关的，可以消去。于是得到</p>
<p><strong>P(Girl|Pants) = P(Girl) <em> P(Pants|Girl) / [P(Boy) </em> P(Pants|Boy) + P(Girl) * P(Pants|Girl)]</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，如果把上式收缩起来，分母其实就是 P(Pants) ，分子其实就是 P(Pants, Girl) 。而这个比例很自然地就读作：在穿长裤的人（ P(Pants) ）里面有多少（穿长裤）的女孩（ P(Pants, Girl) ）。<br>进一步得到公式的一般形式：</p>
<p><strong>P(B|A) = P(A|B) <em> P(B) / [P(A|B) </em> P(B) + P(A|~B) * P(~B) ]</strong></p>
<p>收缩起来就是：<strong>P(B|A) = P(AB) / P(A)</strong><br>其实这个就等于：<strong>P(B|A) * P(A) = P(AB)</strong></p>
<h1 id="二、正式的定义"><a href="#二、正式的定义" class="headerlink" title="二、正式的定义"></a>二、正式的定义</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;朴素贝叶斯算法是基于贝叶斯定理与特征条件独立假设的分类方法，然后依据被分类项属于各个类的概率，概率最大者即为所划分的类别。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设输入空间X=（x1,x2,x3…xn），输出类标记为Y=（y1,y2,y3…yn）。x的集合记为X，称为属性集。一般X和Y的关系不确定的，你只能在某种程度上说x有多大可能性属于类y1，比如说x有80%的可能性属于类y1，这时可以把X和Y看做是随机变量，P(Y|X)称为Y的<strong>后验概率</strong>（posterior probability），与之相对的P(Y)称为Y的<strong>先验概率</strong>（prior probability），P(X=x|Y=y1)称之为<strong>条件概率</strong>。</p>
<p><strong>先验概率</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过经验来判断事情发生的概率，比如说“贝叶死”的发病率是万分之一，就是先验概率。再比如南方的梅雨季是 6-7 月，就是通过往年的气候总结出来的经验，这个时候下雨的概率就比其他时间高出很多。</p>
<p><strong>后验概率</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后验概率就是发生结果之后，推测原因的概率。比如说某人查出来了患有“贝叶死”，那么患病的原因可能是 A、B 或 C。患有“贝叶死”是因为原因 A 的概率就是后验概率。它是属于条件概率的一种。</p>
<p><strong>条件概率</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件 A 在另外一个事件 B 已经发生条件下的发生概率，表示为 P(A|B)，读作“在 B 发生的条件下 A 发生的概率”。比如原因 A 的条件下，患有“贝叶死”的概率，就是条件概率。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单说来就是：贝叶斯分类算法的理论基于贝叶斯公式：<br><img src="https://img-blog.csdnimg.cn/20190816085605498.png" alt></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中P(A|B)称为<strong>条件概率</strong>，P(B)<strong>先验概率</strong>，对应P(B|A)为<strong>后验概率</strong>。朴素贝叶斯分类器基于一个简单的假定，即给定的目标值属性之间是相互独立。贝叶斯公式之所以有用是因为在日常生活中，我们可以很容易得到P(A|B)，而很难得出P(B|A)，但我们更关心P(B|A)，所以就可以根据贝叶斯公式来计算。</p>
<h1 id="三、应用举例"><a href="#三、应用举例" class="headerlink" title="三、应用举例"></a>三、应用举例</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下表所示，训练数据学习一个朴素贝叶斯分类器并确定x=(2,S)T的类标记y。表中x1、x2为特征，取值的集合分别为X1={1,2,3}，X2={S,M,L}，类标记Y={1,-1}</p>
<p><img src="https://img-blog.csdnimg.cn/20190816084258206.png" alt><br>根据贝叶斯算法得到如下概率：</p>
<p>P(Y=1)=9/15，P(Y=-1)=6/15</p>
<p>P(X1=1|Y=1)=2/9，P(X1=2|Y=1)=3/9，P(X1=3|Y=1)=4/9</p>
<p>P(X2=S|Y=1)=1/9，P(X2=M|Y=1)=4/9，P(X2=L|Y=1)=4/9</p>
<p>P(X1=1|Y=-1)=3/6，P(X1=2|Y=-1)=2/6，P(X1=3|Y=-1)=1/6</p>
<p>P(X2=S|Y=-1)=3/6，P(X2=M|Y=-1)=2/6，P((X2=L|Y=-1)=1/6</p>
<p>所以对于给定的x=(2,S)T计算：</p>
<p>P(Y=1)P(X1=2|Y=1)P(X2=S|Y=1)=(9/15)(3/9)(1/9)=1/45</p>
<p>P(Y=-1)P(X1=2|Y=-1)P(X2=S|Y=-1)=(6/15)(2/6)(1/6)=1/15</p>
<p>所以分类结果为y=-1</p>
<h1 id="四、朴素贝叶斯算法的优缺点"><a href="#四、朴素贝叶斯算法的优缺点" class="headerlink" title="四、朴素贝叶斯算法的优缺点"></a>四、朴素贝叶斯算法的优缺点</h1><p><strong>优点：</strong></p>
<ol>
<li>朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率；</li>
<li>对大数量训练和查询时具有较高的速度。即使使用超大规模的训练集，针对每个项目通常也只会有相对较少的特征数，并且对项目的训练和分类也仅仅是特征概率的数学运算而已；</li>
<li>对小规模的数据表现很好，能个处理多分类任务，适合增量式训练（即可以实时的对新增的样本进行训练）；</li>
<li>对缺失数据不太敏感，算法也比较简单，常用于文本分类；</li>
<li>朴素贝叶斯对结果解释容易理解。</li>
</ol>
<p> <strong>缺点</strong></p>
<ol>
<li>需要计算先验概率；</li>
<li>分类决策存在错误率；</li>
<li>对输入数据的表达形式很敏感；</li>
<li>由于使用了样本属性独立性的假设，所以如果样本属性有关联时其效果不好。</li>
</ol>
<h1 id="五、应用领域"><a href="#五、应用领域" class="headerlink" title="五、应用领域"></a>五、应用领域</h1><ol>
<li>欺诈检测中使用较多；</li>
<li>一封电子邮件是否是垃圾邮件；</li>
<li>一篇文章应该分到科技、政治，还是体育类；</li>
<li>一段文字表达的是积极的情绪还是消极的情绪；</li>
<li>人脸识别</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>朴素贝叶斯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统之矩阵分解(MF)及其python实现</title>
    <url>/2019/07/23/tui-jian-xi-tong-zhi-ju-zhen-fen-jie-mf-ji-qi-python-shi-xian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前推荐系统中用的最多的就是矩阵分解方法，在Netflix Prize推荐系统大赛中取得突出效果。以用户-项目评分矩阵为例，矩阵分解就是预测出评分矩阵中的缺失值，然后根据预测值以某种方式向用户推荐。今天以“用户-项目评分矩阵R（M×N）”说明矩阵分解方式的原理以及python实现。</p>
<h1 id="一、矩阵分解"><a href="#一、矩阵分解" class="headerlink" title="一、矩阵分解"></a>一、矩阵分解</h1><h2 id="1-案例引入"><a href="#1-案例引入" class="headerlink" title="1.案例引入"></a>1.案例引入</h2><p>有如下R(5,4)的打分矩阵：（“-”表示用户没有打分）</p>
<p>其中打分矩阵R(n,m)是n行和m列，n表示user个数，m行表示item个数<br><img src="https://img-blog.csdnimg.cn/20190727200249638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt><br>那么，如何根据目前的矩阵R（5,4）如何对未打分的商品进行评分的预测（如何得到分值为0的用户的打分值）？</p>
<p>——矩阵分解的思想可以解决这个问题，其实这种思想可以看作是有监督的机器学习问题（回归问题）。</p>
<p>矩阵分解的过程中，,矩阵R可以近似表示为矩阵P与矩阵Q的乘积：<br><img src="https://img-blog.csdnimg.cn/2019072720060093.png" alt><br>矩阵P(n,k)表示n个user和k个特征之间的关系矩阵，这k个特征是一个中间变量，矩阵Q(k,m)的转置是矩阵Q(m,k)，矩阵Q(m,k)表示m个item和K个特征之间的关系矩阵，这里的k值是自己控制的，可以使用交叉验证的方法获得最佳的k值。为了得到近似的R(n,m)，必须求出矩阵P和Q，如何求它们呢？</p>
<h2 id="2-推导步骤"><a href="#2-推导步骤" class="headerlink" title="2.推导步骤"></a>2.推导步骤</h2><ol>
<li>首先令：<br><img src="https://img-blog.csdnimg.cn/2019072720192687.png" alt="式子1"></li>
<li>对于式子1的左边项，表示的是r^ 第i行，第j列的元素值，对于如何衡量，我们分解的好坏呢，式子2，给出了衡量标准，也就是损失函数，平方项损失，最后的目标，就是每一个元素(非缺失值)的e(i,j)的总和最小值<br> <img src="https://img-blog.csdnimg.cn/20190727202015695.png" alt="式子2"></li>
<li>使用梯度下降法获得修正的p和q分量：<ul>
<li><strong>求解损失函数的负梯度</strong>：<br><img src="https://img-blog.csdnimg.cn/20190727202620356.png" alt></li>
<li><strong>根据负梯度的方向更新变量</strong>：<br><img src="https://img-blog.csdnimg.cn/20190727202652714.png" alt></li>
</ul>
</li>
<li><p>不停迭代直到算法最终收敛（直到sum(e^2) &lt;=阈值，即梯度下降结束条件：f(x)的真实值和预测值小于自己设定的阈值）</p>
</li>
<li><p>为了防止过拟合，增加正则化项</p>
</li>
</ol>
<h2 id="3-加入正则项的损失函数求解"><a href="#3-加入正则项的损失函数求解" class="headerlink" title="3.加入正则项的损失函数求解"></a>3.加入正则项的损失函数求解</h2><ol>
<li>通常在求解的过程中，为了能够有较好的泛化能力，会在损失函数中加入正则项，以对参数进行约束，加入正则L2范数的损失函数为：<br> <img src="https://img-blog.csdnimg.cn/20190727203202194.png" alt><br> 对正则化不清楚的，公式可化为：<br> <img src="https://img-blog.csdnimg.cn/20190727203315849.png" alt></li>
<li>使用梯度下降法获得修正的p和q分量：<ul>
<li><strong>求解损失函数的负梯度</strong>：<br><img src="https://img-blog.csdnimg.cn/20190727203526974.png" alt></li>
<li><strong>根据负梯度的方向更新变量</strong>：<br><img src="https://img-blog.csdnimg.cn/20190727203554346.png" alt></li>
</ul>
</li>
</ol>
<h2 id="4-预测"><a href="#4-预测" class="headerlink" title="4.预测"></a>4.预测</h2><p>预测利用上述的过程，我们可以得到矩阵和，这样便可以为用户 i 对商品 j 进行打分：<br> <img src="https://img-blog.csdnimg.cn/20190727203756990.png" alt></p>
<h1 id="二、python代码实现"><a href="#二、python代码实现" class="headerlink" title="二、python代码实现"></a>二、python代码实现</h1><p>以下是根据上文的评分例子做的一个矩阵分解算法，并且附有代码详解。</p>
<pre><code>from math import *
import numpy
import matplotlib.pyplot as plt

def matrix_factorization(R,P,Q,K,steps=5000,alpha=0.0002,beta=0.02): #矩阵因子分解函数，steps：梯度下降次数；alpha：步长；beta：β。
    Q=Q.T                 # .T操作表示矩阵的转置
    result=[]
    for step in range(steps): #梯度下降
        for i in range(len(R)):
            for j in range(len(R[i])):
                    eij=R[i][j]-numpy.dot(P[i,:],Q[:,j])       # .DOT表示矩阵相乘
                    for k in range(K):
                      if R[i][j]&gt;0:        #限制评分大于零
                        P[i][k]=P[i][k]+alpha*(2*eij*Q[k][j]-beta*P[i][k])   #增加正则化，并对损失函数求导，然后更新变量P
                        Q[k][j]=Q[k][j]+alpha*(2*eij*P[i][k]-beta*Q[k][j])   #增加正则化，并对损失函数求导，然后更新变量Q
        eR=numpy.dot(P,Q)  
        e=0
        for i in range(len(R)):
            for j in range(len(R[i])):
              if R[i][j]&gt;0:
                    e=e+pow(R[i][j]-numpy.dot(P[i,:],Q[:,j]),2)      #损失函数求和
                    for k in range(K):
                        e=e+(beta/2)*(pow(P[i][k],2)+pow(Q[k][j],2)) #加入正则化后的损失函数求和
        result.append(e)
        if e&lt;0.001:           #判断是否收敛，0.001为阈值
            break
    return P,Q.T,result

if __name__ == &#39;__main__&#39;:   #主函数
    R=[                 #原始矩阵
        [5,3,0,1],
        [4,0,0,1],
        [1,1,0,5],
        [1,0,0,4],
        [0,1,5,4]
    ]
    R=numpy.array(R)
    N=len(R)    #原矩阵R的行数
    M=len(R[0]) #原矩阵R的列数
    K=3    #K值可根据需求改变
    P=numpy.random.rand(N,K) #随机生成一个 N行 K列的矩阵
    Q=numpy.random.rand(M,K) #随机生成一个 M行 K列的矩阵
    nP,nQ,result=matrix_factorization(R,P,Q,K)
    print(R)         #输出原矩阵
    R_MF=numpy.dot(nP,nQ.T)
    print(R_MF)      #输出新矩阵
    #画图
    plt.plot(range(len(result)),result)
    plt.xlabel(&quot;time&quot;)
    plt.ylabel(&quot;loss&quot;)
    plt.show()
</code></pre>]]></content>
      <categories>
        <category>机器学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
        <tag>推荐系统</tag>
        <tag>矩阵分解</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降法</title>
    <url>/2019/07/18/ti-du-xia-jiang-fa-de-san-chong-xing-shi-bgd-sgd-mbgd-ji-python-shi-xian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;梯度下降法作为机器学习中较常使用的优化算法，其有着三种不同的形式：批量梯度下降（Batch Gradient Descent）、随机梯度下降（Stochastic Gradient Descent）以及小批量梯度下降（Mini-Batch Gradient Descent）。其中小批量梯度下降法也常用在深度学习中进行模型的训练。接下来，我们将对这三种不同的梯度下降法进行理解。</p>
<p>为了便于理解，这里我们将使用只含有一个特征的线性回归来展开。</p>
<p>此时线性回归的假设函数为：<br><img src="https://img-blog.csdnimg.cn/20190725100634816.png" alt><br>对应的<strong>目标函数（代价函数）</strong>即为：<br> <img src="https://img-blog.csdnimg.cn/20190725085658136.png" alt><br>下图为 J(θ0,θ1)与参数 θ0,θ1 的关系的图：<br><img src="https://img-blog.csdnimg.cn/20190725090156368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="1、批量梯度下降（Batch-Gradient-Descent，BGD）"><a href="#1、批量梯度下降（Batch-Gradient-Descent，BGD）" class="headerlink" title="1、批量梯度下降（Batch Gradient Descent，BGD）"></a>1、批量梯度下降（Batch Gradient Descent，BGD）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>批量梯度下降法</strong>是最原始的形式，它是指在<strong>每一次迭代时</strong>使用<strong>所有样本</strong>来进行梯度的更新。从数学上理解如下：<br>  （1）对目标函数求偏导：<br>  <img src="https://img-blog.csdnimg.cn/20190725085839458.png" alt><br>  其中 i=1,2,…,m 表示样本数， j=0,1 表示特征数，这里我们使用了偏置项 x(i)0=1。<br>  （2）每次迭代对参数进行更新：<br>  <img src="https://img-blog.csdnimg.cn/2019072508594192.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意这里更新时存在一个求和函数，即为对所有样本进行计算处理，可与下文SGD法进行比较。</strong><br>  伪代码形式为：<br>  <img src="https://img-blog.csdnimg.cn/201907250859587.png" alt><br>  <strong>优点</strong>：<br>  （1）一次迭代是对所有样本进行计算，此时利用矩阵进行操作，实现了并行。<br>  （2）由全数据集确定的方向能够更好地代表样本总体，从而更准确地朝向极值所在的方向。当目标函数为凸函数时，BGD一定能够得到全局最优。<br>  <strong>缺点</strong>：<br>  （1）当样本数目 mm 很大时，每迭代一步都需要对所有样本计算，训练过程会很慢。<br>  从迭代的次数上来看，BGD迭代的次数相对较少。其迭代的收敛曲线示意图可以表示如下：<br>  <img src="https://img-blog.csdnimg.cn/20190725090052713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="批量梯度下降法的python实现"><a href="#批量梯度下降法的python实现" class="headerlink" title="批量梯度下降法的python实现"></a>批量梯度下降法的python实现</h2><pre><code>import matplotlib.pyplot as plt
import random
##样本数据
x_train = [150,200,250,300,350,400,600]
y_train = [6450,7450,8450,9450,11450,15450,18450]
#样本个数
m = len(x_train)
#步长
alpha = 0.00001
#循环次数
cnt = 0
#假设函数为 y=theta0+theta1*x
def h(x):
    return theta0 + theta1*x
theta0 = 0
theta1 = 0
#导数
diff0=0
diff1=0
#误差
error0=0           
error1=0          
#每次迭代theta的值
retn0 = []         
retn1 = []         

#退出迭代的条件
epsilon=0.00001

#批量梯度下降
while 1:
    cnt=cnt+1
    diff0=0
    diff1=0
    #梯度下降
    for i in range(m):
        diff0+=h(x_train[i])-y_train[i]
        diff1+=(h(x_train[i])-y_train[i])*x_train[i]
    theta0=theta0-alpha/m*diff0
    theta1=theta1-alpha/m*diff1
    retn0.append(theta0)
    retn1.append(theta1)
    error1=0
    #计算迭代误差
    for i in range(len(x_train)):
        error1 += ((theta0 + theta1 * x_train[i])-y_train[i]) ** 2 / 2
    #判断是否已收敛
    if abs(error1 - error0) &lt; epsilon:
        break
    else:
        error0 = error1
# 画图表现
plt.title(&#39;BGD&#39;)
plt.plot(range(len(retn0)),retn0,label=&#39;theta0&#39;)
plt.plot(range(len(retn1)),retn1,label=&#39;theta1&#39;)
plt.legend()          #显示上面的label
plt.xlabel(&#39;time&#39;)
plt.ylabel(&#39;theta&#39;)
plt.show()
plt.plot(x_train,y_train,&#39;bo&#39;)
plt.plot(x_train,[h(x) for x in x_train],color=&#39;k&#39;,label=&#39;BGD&#39;)
plt.legend()
plt.xlabel(&#39;area&#39;)
plt.ylabel(&#39;price&#39;)
print(&quot;批量梯度下降法：theta0={},theta1={}&quot;.format(theta0,theta1))
print(&quot;批量梯度下降法循环次数：{}&quot;.format(cnt))
plt.show()
</code></pre><h2 id="2、随机梯度下降（Stochastic-Gradient-Descent，SGD）"><a href="#2、随机梯度下降（Stochastic-Gradient-Descent，SGD）" class="headerlink" title="2、随机梯度下降（Stochastic Gradient Descent，SGD）"></a>2、随机梯度下降（Stochastic Gradient Descent，SGD）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp<strong>;随机梯度下降法</strong>不同于批量梯度下降，随机梯度下降是<strong>每次迭代</strong>使用<strong>一个样本</strong>来对参数进行更新。使得训练速度加快。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个样本的目标函数为：<br>  <img src="https://img-blog.csdnimg.cn/20190725090216938.png" alt><br>  （1）对目标函数求偏导：<br>  <img src="https://img-blog.csdnimg.cn/20190725090246509.png" alt><br>  （2）参数更新：<br>  <img src="https://img-blog.csdnimg.cn/20190725090315940.png" alt><br>  <strong>注意，这里不再有求和符号</strong><br>  伪代码形式为：<br>  <img src="https://img-blog.csdnimg.cn/20190725090345289.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>优点</strong>：<br>  （1）由于不是在全部训练数据上的损失函数，而是在每轮迭代中，随机优化某一条训练数据上的损失函数，这样每一轮参数的更新速度大大加快。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>缺点</strong>：<br>  （1）准确度下降。由于即使在目标函数为强凸函数的情况下，SGD仍旧无法做到线性收敛。<br>  （2）可能会收敛到局部最优，由于单个样本并不能代表全体样本的趋势。<br>  （3）不易于并行实现。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>解释一下为什么SGD收敛速度比BGD要快：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答：这里我们假设有30W个样本，对于BGD而言，每次迭代需要计算30W个样本才能对参数进行一次更新，需要求得最小值可能需要多次迭代（假设这里是10）；而对于SGD，每次更新参数只需要一个样本，因此若使用这30W个样本进行参数更新，则参数会被更新（迭代）30W次，而这期间，SGD就能保证能够收敛到一个合适的最小值上了。也就是说，在收敛时，BGD计算了 10×30W 次，而SGD只计算了 1×30W 次。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从迭代的次数上来看，SGD迭代的次数较少，在解空间的搜索过程看起来很盲目。其迭代的收敛曲线示意图可以表示如下：<br>  <img src="https://img-blog.csdnimg.cn/20190725090459507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="随机梯度下降法的python实现"><a href="#随机梯度下降法的python实现" class="headerlink" title="随机梯度下降法的python实现"></a>随机梯度下降法的python实现</h2><pre><code>import matplotlib.pyplot as plt
import random
##样本数据
x_train = [150,200,250,300,350,400,600]
y_train = [6450,7450,8450,9450,11450,15450,18450]
#样本个数
m = len(x_train)
#步长
alpha = 0.00001
#循环次数
cnt = 0
#假设函数为 y=theta0+theta1*x
def h(x):
    return theta0 + theta1*x
theta0 = 0
theta1 = 0
#导数
diff0=0
diff1=0
#误差
error0=0           
error1=0          
#每次迭代theta的值
retn0 = []         
retn1 = []         

#退出迭代的条件
epsilon=0.00001

#随机梯度下降
for i in range(1000):
    cnt=cnt+1
    diff0=0
    diff1=0
    j = random.randint(0, m - 1)
    diff0=h(x_train[j])-y_train[j]
    diff1=(h(x_train[j])-y_train[j])*x_train[j]
    theta0=theta0-alpha/m*diff0
    theta1=theta1-alpha/m*diff1
    retn0.append(theta0)
    retn1.append(theta1)
    error1=0
    #计算迭代的误差
    for i in range(len(x_train)):
        error1 += ((theta0 + theta1 * x_train[i])-y_train[i]) ** 2 / 2
    #判断是否已收敛
    if abs(error1 - error0) &lt; epsilon:
        break
    else:
        error0 = error1
# 画图表现        
plt.title(&#39;SGD&#39;)
plt.plot(range(len(retn0)),retn0,label=&#39;theta0&#39;)
plt.plot(range(len(retn1)),retn1,label=&#39;theta1&#39;)
plt.legend()          #显示上面的label
plt.xlabel(&#39;time&#39;)
plt.ylabel(&#39;theta&#39;)
plt.show()
plt.plot(x_train,y_train,&#39;bo&#39;)
plt.plot(x_train,[h(x) for x in x_train],color=&#39;k&#39;,label=&#39;SGD&#39;)
plt.legend()
plt.xlabel(&#39;area&#39;)
plt.ylabel(&#39;price&#39;)
print(&quot;随机梯度下降法：theta0={},theta1={}&quot;.format(theta0,theta1))
print(&quot;随机梯度下降法循环次数：{}&quot;.format(cnt))
plt.show()
</code></pre><h2 id="3、小批量梯度下降（Mini-Batch-Gradient-Descent-MBGD）"><a href="#3、小批量梯度下降（Mini-Batch-Gradient-Descent-MBGD）" class="headerlink" title="3、小批量梯度下降（Mini-Batch Gradient Descent, MBGD）"></a>3、小批量梯度下降（Mini-Batch Gradient Descent, MBGD）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>小批量梯度下降</strong>，是对批量梯度下降以及随机梯度下降的一个折中办法。其思想是：<strong>每次迭代</strong> 使用 <strong>batch_size 个样本</strong>来对参数进行更新。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们假设 batchsize=10，样本数 m=1000 。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伪代码形式为：<br>  <img src="https://img-blog.csdnimg.cn/20190725090543904.png" alt><br>  <strong>优点</strong>：<br>  （1）通过矩阵运算，每次在一个batch上优化神经网络参数并不会比单个数据慢太多。<br>  （2）每次使用一个batch可以大大减小收敛所需要的迭代次数，同时可以使收敛到的结果更加接近梯度下降的效果。(比如上例中的30W，设置batch_size=100时，需要迭代3000次，远小于SGD的30W次)<br>  （3）可实现并行化。<br>  <strong>缺点</strong>：<br>  （1）batch_size的不当选择可能会带来一些问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>batcha_size的选择带来的影响：</strong><br>  （1）在合理地范围内，增大batch_size的好处：<br>    a. 内存利用率提高了，大矩阵乘法的并行化效率提高。<br>    b. 跑完一次 epoch（全数据集）所需的迭代次数减少，对于相同数据量的处理速度进一步加快。<br>    c. 在一定范围内，一般来说 Batch_Size 越大，其确定的下降方向越准，引起训练震荡越小。<br>  （2）盲目增大batch_size的坏处：<br>    a. 内存利用率提高了，但是内存容量可能撑不住了。<br>    b. 跑完一次 epoch（全数据集）所需的迭代次数减少，要想达到相同的精度，其所花费的时间大大增加了，从而对参数的修正也就显得更加缓慢。<br>    c. Batch_Size 增大到一定程度，其确定的下降方向已经基本不再变化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图显示了三种梯度下降算法的收敛过程：<br>  <img src="https://img-blog.csdnimg.cn/20190725090635209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p><strong>Batch gradient descent:</strong> Use all examples in each iteration；</p>
<p><strong>Stochastic gradient descent:</strong> Use 1 example in each iteration；</p>
<p><strong>Mini-batch gradient descent:</strong> Use b examples in each iteration.</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title>数据集的划分</title>
    <url>/2019/07/18/shu-ju-ji-de-hua-fen-xun-lian-ji-yan-zheng-ji-he-ce-shi-ji/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在机器学习中，经常提到训练集和测试集，验证集似有似无。感觉挺好奇的，就仔细查找了文献。以下谈谈训练集、验证集和测试集。</p>
<h2 id="为什么要划分数据集为训练集、验证集和测试集？"><a href="#为什么要划分数据集为训练集、验证集和测试集？" class="headerlink" title="为什么要划分数据集为训练集、验证集和测试集？"></a>为什么要划分数据集为训练集、验证集和测试集？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做科研，就要提出问题，找到解决方法，并证明其有效性。这里的工作有3个部分，一个是提出问题，一个是找到解决方法，另一个是证明有效性。每一个部分都可以作为科研的对象，研究的越靠前，则越偏向科学，越靠后，则越偏向技术，因此叫做科学与技术。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在人工智能领域，证明一个模型的有效性，就是对于某一问题，有一些数据，而我们提出的模型可以（部分）解决这个问题，那如何来证明呢？这和我们平时的考试也是一样的，证明我们掌握了某类知识，就是去参加考试。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好，那么如何设计考试，让这个考试可以较为客观的考察出每个人的能力呢（注意，不是让每个人都得最高分）？回想我们的高中阶段，有一些教材，让我们平时学习其基本知识（训练集），有一些模拟考试，让我们知道我们到底掌握的怎么样，然后再改进我们的学习（验证集），最后的高考决定我们的去向（测试集）。这样的类比，是不是就很清楚了。</p>
<h2 id="训练集、验证集和测试集"><a href="#训练集、验证集和测试集" class="headerlink" title="训练集、验证集和测试集"></a>训练集、验证集和测试集</h2><pre><code>1. **训练集**：顾名思义指的是用于训练的样本集合,主要用来训练神经网络中的参数。

2. **验证集**：从字面意思理解即为用于验证模型性能的样本集合.不同神经网络在训练集上训练结束后,通过验证集来比较判断各个模型的性能.这里的不同模型主要是指对应不同超参数的神经网络,也可以指完全不同结构的神经网络。

3. **测试集**：对于训练完成的神经网络,测试集用于客观的评价神经网络的性能。
</code></pre><h2 id="如何划分训练集、验证集和测试集"><a href="#如何划分训练集、验证集和测试集" class="headerlink" title="如何划分训练集、验证集和测试集"></a>如何划分训练集、验证集和测试集</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个问题其实非常基础，也非常明确，在Scikit-learn里提供了各种各样的划分方法。无论是单一的训练集、验证集和测试集，还是进行交叉验证，你都会找到调用的方法，因此我们这里主要介绍两种常见的方法。</p>
<pre><code>1. 前人给出训练集、验证集和测试集
  对于这种情况，那么只能跟随前人的数据划分进行，一般的比赛也是如此。一定不要使用测试集来调整性能（测试集已知的情况下），尽管存在使用这种方法来提升模型的性能的行为，但是我们并不推荐这么做。最正常的做法应当是使用训练集来学习，并使用验证集来调整超参数。当在验证集上取得最优的模型时，此时就可以使用此模型的超参数来重新训练（训练集+验证集），并用测试集评估最终的性能。
    我们首先说明加入验证集重新训练和不加有啥区别，从理论上讲，一方面学习的样本增多，应当是会提升模型性能的，第二，其在验证集上取得最优的模型与验证集的分布的契合度是最高的，因此最终的模型会更接近验证集的分布。
    其次再说明验证集和测试集上的性能差异。事实上，在验证集上取得最优的模型，未必在测试集上取得最优。其原因就是训练的模型是否对于该问题有着较好的泛化能力，即没有对验证集产生过拟合现象。正因为有这种情况的发生，才会有人使用测试集的最优值作为最终的结果（而不管验证集的好坏）。

2. 前人没有明确给出数据集的划分
  这时候可以采取第一种划分方法，对于样本数较小的数据集，同样可以采取交叉验证的方法。
    交叉验证的方法的使用场景有很多，我们这里是针对不同的模型的性能好坏进行评估。
    使用交叉验证，可以获得更为客观的性能差异。当使用第一种方法时，我们更建议使用P值来做显著性检验，从而保证性能差异的客观性。而使用第二种方法，即交叉验证时，我们选取其性能表现的均值作为最终的结果，更能体现该模型的泛化能力。
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.存在验证集<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里五倍交叉验证是用于进行调参，此时不接触测试集。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据集首先划分出训练集与测试集（可以是4:1或者9:1）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，在训练集中，再划分出验证集（通常也是4:1或者9：1）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后对于训练集和验证集进行5折交叉验证，选取出最优的超参数，然后把训练集和验证集一起训练出最终的模型。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.不存在验证集<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该情况通常是对比不同的模型，如自己的模型和别人的模型的性能好坏。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需要把数据集划分为训练集和测试集即可，然后选取5次试验的平均值作为最终的性能评价。</p>
<h2 id="验证集和测试集的区别"><a href="#验证集和测试集的区别" class="headerlink" title="验证集和测试集的区别"></a>验证集和测试集的区别</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么,训练集、校验集和测试集之间又有什么区别呢?一般而言,训练集与后两者之间较易分辨,校验集和测试集之间的概念较易混淆.个人是从下面的角度来理解的:</p>
<ul>
<li><p>神经网络在网络结构确定的情况下,有两部分影响模型最终的性能,一是普通参数(比如权重w和偏置b),另一个是超参数(例如学习率,网络层数).普通参数我们在训练集上进行训练,超参数我们一般人工指定(比较不同超参数的模型在校验集上的性能).那为什么我们不像普通参数一样在训练集上训练超参数呢?(花书给出了解答)一是：超参数一般难以优化(无法像普通参数一样通过梯度下降的方式进行优化).二是：超参数很多时候不适合在训练集上进行训练,例如,如果在训练集上训练能控制模型容量的超参数,这些超参数总会被训练成使得模型容量最大的参数(因为模型容量越大,训练误差越小),所以训练集上训练超参数的结果就是模型绝对过拟合.</p>
</li>
<li><p>正因为超参数无法在训练集上进行训练,因此我们单独设立了一个验证集,用于选择(人工训练)最优的超参数.因为验证集是用于选择超参数的,因此校验集和训练集是独立不重叠的.</p>
</li>
<li><p>测试集是用于在完成神经网络训练过程后,为了<strong>客观评价模型</strong>在其未见过(未曾影响普通参数和超参数选择)的数据上的性能,因此测试与验证集和训练集之间也是独立不重叠的,而且测试集不能提出对参数或者超参数的修改意见,只能作为评价网络性能的一个指标.</p>
</li>
</ul>
<p>为了方便清楚直观的了解，上一个表格：<br><img src="https://img-blog.csdnimg.cn/20190724110042475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQxMzEy,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此,我们可以将神经网络完整的训练过程归结为一下两个步骤:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.训练普通参数.在训练集(给定超参数)上利用学习算法,训练普通参数,使得模型在训练集上的误差降低到可接受的程度(一般接近人类的水平).</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.’训练’超参数.在验证集上验证网络的generalization error(泛化能力),并根据模型性能对超参数进行调整.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重复1和2两个步骤,直至网络在验证集上取得较低的generalization error.此时完整的训练过程结束.在完成参数和超参数的训练后,在测试集上测试网络的性能.</p>
<h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h2><p>说到底：</p>
<ul>
<li><p>验证集是一定需要的；</p>
</li>
<li><p>如果验证集具有足够泛化代表性，是不需要再整出什么测试集的；</p>
</li>
<li><p>整个测试集往往就是为了在验证集只是非训练集一个小子集的情况下，好奇一下那个靠训练集（训练）和验证集（调参）多次接力训练出来的模型是不是具有了泛化性能，因而加试一下图个确定。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈机器学习-分类和聚类的区别</title>
    <url>/2019/08/01/qian-tan-ji-qi-xue-xi-fen-lei-he-ju-lei-de-qu-bie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;机器学习中有两类的大问题，一个是分类，一个是聚类。在我们的生活中，我们常常没有过多的去区分这两个概念，觉得聚类就是分类，分类也差不多就是聚类，下面，我们就具体来研究下分类与聚类之间在数据挖掘中本质的区别。</p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>分类有如下几种说法，但表达的意思是相同的。</p>
<ul>
<li>分类（classification）:分类任务就是通过学习得到一个目标函数f，把每个属性集x映射到一个预先定义的类标号y中。</li>
<li>分类是根据一些给定的已知类别标号的样本，训练某种学习机器（即得到某种目标函数），使它能够对未知类别的样本进行分类。这属于supervised learning（监督学习）。</li>
<li>分类：通过学习来得到样本属性与类标号之间的关系。<br>用自己的话来说，就是我们根据已知的一些样本（包括属性与类标号）来得到分类模型（即得到样本属性与类标号之间的函数），然后通过此目标函数来对只包含属性的样本数据进行分类。</li>
</ul>
<p><strong>分类算法的局限</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分类作为一种监督学习方法，要求必须事先明确知道各个类别的信息，并且断言所有待分类项都有一个类别与之对应。但是很多时候上述条件得不到满足，尤其是在处理海量数据的时候，如果通过预处理使得数据满足分类算法的要求，则代价非常大，这时候可以考虑使用聚类算法。</p>
<h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><p>聚类的相关的一些概念如下</p>
<ul>
<li>聚类指事先并不知道任何样本的类别标号，希望通过某种算法来把一组未知类别的样本划分成若干类别，聚类的时候，我们并不关心某一类是什么，我们需要实现的目标只是把相似的东西聚到一起，这在机器学习中被称作 unsupervised learning （无监督学习）</li>
<li>通常，人们根据样本间的某种距离或者相似性来定义聚类，即把相似的（或距离近的）样本聚为同一类，而把不相似的（或距离远的）样本归在其他类。</li>
<li>聚类的目标：组内的对象相互之间时相似的（相关的），而不同组中的对象是不同的（不相关的）。组内的相似性越大，组间差别越大，聚类就越好。</li>
</ul>
<h1 id="分类与聚类的比较"><a href="#分类与聚类的比较" class="headerlink" title="分类与聚类的比较"></a>分类与聚类的比较</h1><ul>
<li>分类：有训练数据，且训练数据包含输入和输出（有监督学习），已知分类的类别（即训练数据的输出）。学习出一个模型，用该模型对未分好类（预测数据）的数据进行预测分类（已知的类别中）。</li>
<li>聚类：训练数据只有输入（无监督学习）。训练过程即预测过程（聚类过程），且不知道类别，甚至不知道有多少个类别，类别的数量需要指定（K-means）,也可以直接通过算法学习出来（DBSCAN）。只能通过特征的相似性对样本分类。该过程即聚类。</li>
<li>聚类分析是研究如何在没有训练的条件下把样本划分为若干类。</li>
<li>在分类中，对于目标数据库中存在哪些类是知道的，要做的就是将每一条记录分别属于哪一类标记出来。</li>
<li>聚类需要解决的问题是将已给定的若干无标记的模式聚集起来使之成为有意义的聚类，聚类是在预先不知道目标数据库到底有多少类的情况下，希望将所有的记录组成不同的类或者说聚类，并且使得在这种分类情况下，以某种度量（例如：距离）为标准的相似性，在同一聚类之间最小化，而在不同聚类之间最大化。</li>
<li>与分类不同，无监督学习不依赖预先定义的类或带类标记的训练实例，需要由聚类学习算法自动确定标记，而分类学习的实例或数据样本有类别标记。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈机器学习-回归与分类的区别</title>
    <url>/2019/08/01/qian-tan-ji-qi-xue-xi-hui-gui-yu-fen-lei-de-qu-bie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;机器学习的主要任务便是聚焦于两个问题：分类和回归。本文将浅谈下两者的区别。</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回归会给出一个具体的结果，例如房价的数据，根据位置、周边、配套等等这些维度，给出一个房价的预测。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分类相信大家都不会陌生，生活中会见到很多的应用，比如垃圾邮件识别、信用卡发放等等，就是基于数据集，作出二分类或者多分类的选择。</p>
<p>浅层： 两者的的预测目标变量类型不同，回归问题是连续变量，分类问题离散变量。<br>中层： 回归问题是定量问题，分类问题是定性问题。<br>高层： 回归与分类的根本区别在于输出空间是否为一个度量空间。<br><img src="https://img-blog.csdnimg.cn/20190318195051810.png" alt></p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>分类和回归的区别在于输出变量的类型。</p>
<p>定量输出称为回归，或者说是连续变量预测；<br>定性输出称为分类，或者说是离散变量预测。</p>
<p>举个例子：<br>预测明天的气温是多少度，这是一个回归任务；<br>预测明天是阴、晴还是雨，就是一个分类任务。</p>
<h1 id="应用场景不同"><a href="#应用场景不同" class="headerlink" title="应用场景不同"></a>应用场景不同</h1><p>1.回归问题的应用场景</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回归问题通常是用来预测一个值，如预测房价、未来的天气情况等等，例如一个产品的实际价格为500元，通过回归分析预测值为499元，我们认为这是一个比较好的回归分析。一个比较常见的回归算法是线性回归算法（LR）。另外，回归分析用在神经网络上，其最上层是不需要加上softmax函数的，而是直接对前一层累加即可。回归是对真实值的一种逼近预测。</p>
<p>2.分类问题的应用场景</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分类问题是用于将事物打上一个标签，通常结果为离散值。例如判断一幅图片上的动物是一只猫还是一只狗，分类通常是建立在回归之上，分类的最后一层通常要使用softmax函数进行判断其所属类别。分类并没有逼近的概念，最终正确结果只有一个，错误的就是错误的，不会有相近的概念。最常见的分类方法是逻辑回归，或者叫逻辑分类。</p>
<h1 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分类模型和回归模型本质一样，都是要建立映射关系。在实际操作中，我们确实常常将回归问题和分类问题互相转化，即分类模型可将回归模型的输出离散化，回归模型也可将分类模型的输出连续化。（分类问题回归化：逻辑回归；回归问题分类化：年龄预测问题——&gt;年龄段分类问题）</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>回归</tag>
      </tags>
  </entry>
</search>
